syntax = "proto3";

package lippycat.data;

option go_package = "github.com/endorses/lippycat/api/gen/data";

// DataService handles high-volume packet streaming from hunters to processors
service DataService {
    // StreamPackets is a bidirectional stream for packet transmission
    // Hunter → Processor: Captured packets
    // Processor → Hunter: Acknowledgments and flow control signals
    rpc StreamPackets(stream PacketBatch) returns (stream StreamControl);

    // SubscribePackets allows monitoring clients (like TUI) to receive packet stream
    // Monitoring Client ← Processor/Hunter: Packet batches
    rpc SubscribePackets(SubscribeRequest) returns (stream PacketBatch);

    // SubscribeCorrelatedCalls allows monitoring clients to receive call correlation updates
    // Monitoring Client ← Processor: Correlated call updates
    rpc SubscribeCorrelatedCalls(SubscribeRequest) returns (stream CorrelatedCallUpdate);
}

// PacketBatch contains multiple packets captured by a hunter
message PacketBatch {
    // Unique hunter identifier
    string hunter_id = 1;

    // Batch sequence number (for ordering and loss detection)
    uint64 sequence = 2;

    // Timestamp when batch was created (Unix nanoseconds)
    int64 timestamp_ns = 3;

    // Individual packets in this batch
    repeated CapturedPacket packets = 4;

    // Statistics about this hunter's capture
    BatchStats stats = 5;
}

// CapturedPacket represents a single captured network packet
message CapturedPacket {
    // Packet payload (raw network data)
    bytes data = 1;

    // Capture timestamp (Unix nanoseconds)
    int64 timestamp_ns = 2;

    // Capture length (actual bytes captured)
    uint32 capture_length = 3;

    // Original length (may be > capture_length if truncated)
    uint32 original_length = 4;

    // Interface index where packet was captured
    uint32 interface_index = 5;

    // Link type (Ethernet, Raw IP, etc.) - from libpcap
    uint32 link_type = 6;

    // Optional: Metadata from local analysis
    PacketMetadata metadata = 7;

    // Interface name where packet was captured (e.g., "eth0", "wlan0")
    // This preserves the actual interface name across hierarchical processor chains
    string interface_name = 8;
}

// PacketMetadata contains hunter-side analysis results
message PacketMetadata {
    // Protocol detected (e.g., "SIP", "RTP", "RTCP")
    string protocol = 1;

    // Source IP address
    string src_ip = 2;

    // Destination IP address
    string dst_ip = 3;

    // Source port
    uint32 src_port = 4;

    // Destination port
    uint32 dst_port = 5;

    // Transport protocol (TCP, UDP, etc.)
    string transport = 6;

    // SIP-specific metadata (if applicable)
    SIPMetadata sip = 7;

    // RTP-specific metadata (if applicable)
    RTPMetadata rtp = 8;

    // Generic info string for display (e.g., "SSH-2.0-OpenSSH_...", "Echo Reply")
    string info = 9;

    // Generic key-value details for protocol-specific data
    map<string, string> details = 10;
}

// SIPMetadata for SIP packets
message SIPMetadata {
    // SIP method (INVITE, BYE, REGISTER, etc.)
    string method = 1;

    // Call-ID
    string call_id = 2;

    // From user
    string from_user = 3;

    // To user
    string to_user = 4;

    // Response code (for responses)
    uint32 response_code = 5;

    // P-Asserted-Identity header (RFC 3325)
    string p_asserted_identity = 6;

    // From tag parameter (for dialog correlation)
    string from_tag = 7;

    // To tag parameter (for dialog correlation)
    string to_tag = 8;

    // Full From URI (for display)
    string from_uri = 9;

    // Full To URI (for display)
    string to_uri = 10;
}

// RTPMetadata for RTP packets
message RTPMetadata {
    // SSRC identifier
    uint32 ssrc = 1;

    // Payload type
    uint32 payload_type = 2;

    // Sequence number
    uint32 sequence = 3;

    // Timestamp
    uint32 timestamp = 4;
}

// BatchStats contains statistics about a hunter's capture
message BatchStats {
    // Total packets captured (before filtering)
    uint64 total_captured = 1;

    // Packets that matched filters
    uint64 filtered_matched = 2;

    // Packets dropped (buffer full, etc.)
    uint64 dropped = 3;

    // Current buffer usage percentage (0-100)
    uint32 buffer_usage = 4;
}

// StreamControl messages from processor to hunter
message StreamControl {
    // Acknowledged sequence number
    uint64 ack_sequence = 1;

    // Flow control signal
    FlowControl flow_control = 2;

    // Error message (if any)
    string error = 3;
}

// FlowControl signals
enum FlowControl {
    // Continue sending at current rate
    FLOW_CONTINUE = 0;

    // Slow down transmission
    FLOW_SLOW = 1;

    // Pause transmission temporarily
    FLOW_PAUSE = 2;

    // Resume after pause
    FLOW_RESUME = 3;
}

// SubscribeRequest for monitoring clients to subscribe to packet stream
message SubscribeRequest {
    // Optional: Filter by specific hunter IDs
    // If has_hunter_filter = false: subscribe to all hunters (default)
    // If has_hunter_filter = true and hunter_ids is empty: subscribe to no hunters
    // If has_hunter_filter = true and hunter_ids is non-empty: subscribe to specific hunters
    repeated string hunter_ids = 1;

    // Optional: BPF filter to apply on server side
    string bpf_filter = 2;

    // Client identifier for logging/tracking
    string client_id = 3;

    // Explicitly indicates whether hunter_ids filter is set
    // This distinguishes between "not set" (subscribe to all) and "empty list" (subscribe to none)
    bool has_hunter_filter = 4;
}

// CorrelatedCallUpdate contains information about a call correlated across B2BUA boundaries
message CorrelatedCallUpdate {
    // Correlation ID (hash of normalized tag pair)
    string correlation_id = 1;

    // Normalized tag pair [tag1, tag2] (sorted alphabetically)
    repeated string tag_pair = 2;

    // From user (participant A)
    string from_user = 3;

    // To user (participant B)
    string to_user = 4;

    // Call legs (one per B2BUA hop)
    repeated CallLegInfo legs = 5;

    // Start time (Unix nanoseconds)
    int64 start_time_ns = 6;

    // Last seen time (Unix nanoseconds)
    int64 last_seen_ns = 7;

    // Call state
    string state = 8;
}

// CallLegInfo represents one leg of a multi-hop call
message CallLegInfo {
    // Call-ID for this leg
    string call_id = 1;

    // Hunter ID where this leg was observed
    string hunter_id = 2;

    // Source IP address
    string src_ip = 3;

    // Destination IP address
    string dst_ip = 4;

    // Last SIP method seen
    string method = 5;

    // Last response code seen
    uint32 response_code = 6;

    // Packet count for this leg
    int32 packet_count = 7;

    // Start time for this leg (Unix nanoseconds)
    int64 start_time_ns = 8;

    // Last seen time for this leg (Unix nanoseconds)
    int64 last_seen_ns = 9;
}
