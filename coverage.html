
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/endorses/lippycat/cmd/interfaces.go (41.5%)</option>
				
				<option value="file1">github.com/endorses/lippycat/cmd/root.go (31.6%)</option>
				
				<option value="file2">github.com/endorses/lippycat/cmd/sniff/sniff.go (70.0%)</option>
				
				<option value="file3">github.com/endorses/lippycat/cmd/sniff/voip.go (18.2%)</option>
				
				<option value="file4">github.com/endorses/lippycat/internal/pkg/capture/capture.go (30.9%)</option>
				
				<option value="file5">github.com/endorses/lippycat/internal/pkg/capture/pcaptypes/live.go (75.0%)</option>
				
				<option value="file6">github.com/endorses/lippycat/internal/pkg/capture/pcaptypes/offline.go (100.0%)</option>
				
				<option value="file7">github.com/endorses/lippycat/internal/pkg/capture/pcaptypes/pcapinterface.go (100.0%)</option>
				
				<option value="file8">github.com/endorses/lippycat/internal/pkg/capture/snifferstarter.go (50.0%)</option>
				
				<option value="file9">github.com/endorses/lippycat/internal/pkg/logger/logger.go (100.0%)</option>
				
				<option value="file10">github.com/endorses/lippycat/internal/pkg/voip/calltracker.go (85.1%)</option>
				
				<option value="file11">github.com/endorses/lippycat/internal/pkg/voip/config.go (100.0%)</option>
				
				<option value="file12">github.com/endorses/lippycat/internal/pkg/voip/core.go (100.0%)</option>
				
				<option value="file13">github.com/endorses/lippycat/internal/pkg/voip/rtp.go (93.3%)</option>
				
				<option value="file14">github.com/endorses/lippycat/internal/pkg/voip/sip.go (93.8%)</option>
				
				<option value="file15">github.com/endorses/lippycat/internal/pkg/voip/sipusers/sipusers.go (100.0%)</option>
				
				<option value="file16">github.com/endorses/lippycat/internal/pkg/voip/tcp.go (70.9%)</option>
				
				<option value="file17">github.com/endorses/lippycat/internal/pkg/voip/testhelpers.go (73.3%)</option>
				
				<option value="file18">github.com/endorses/lippycat/internal/pkg/voip/udp.go (83.3%)</option>
				
				<option value="file19">github.com/endorses/lippycat/internal/pkg/voip/writer.go (84.6%)</option>
				
				<option value="file20">github.com/endorses/lippycat/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "fmt"
        "os"
        "strings"

        "github.com/endorses/lippycat/internal/pkg/logger"
        "github.com/google/gopacket/pcap"
        "github.com/spf13/cobra"
)

var interfacesCmd = &amp;cobra.Command{
        Use:   "interfaces",
        Short: "List network interfaces available for monitoring",
        Long:  `List network interfaces that lippycat can monitor for VoIP traffic. Requires appropriate permissions.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                // Check if running with appropriate privileges
                if os.Geteuid() != 0 </span><span class="cov0" title="0">{
                        fmt.Println("Warning: Running without root privileges. Some interfaces may not be accessible.")
                        fmt.Println("Consider running with 'sudo' for full interface access.")
                        fmt.Println()
                }</span>

                <span class="cov0" title="0">devices, err := pcap.FindAllDevs()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error accessing network interfaces", "error", err)
                        fmt.Println("Unable to list network interfaces. This may be due to insufficient permissions.")
                        return
                }</span>

                <span class="cov0" title="0">fmt.Println("Network interfaces suitable for VoIP monitoring:")
                validCount := 0
                for _, device := range devices </span><span class="cov0" title="0">{
                        // Filter out sensitive or irrelevant interfaces
                        if isValidMonitoringInterface(device.Name) </span><span class="cov0" title="0">{
                                validCount++
                                fmt.Printf("  %s", device.Name)

                                // Only show basic, non-sensitive description
                                if device.Description != "" &amp;&amp; !containsSensitiveInfo(device.Description) </span><span class="cov0" title="0">{
                                        // Sanitize description
                                        desc := sanitizeDescription(device.Description)
                                        if desc != "" </span><span class="cov0" title="0">{
                                                fmt.Printf(" - %s", desc)
                                        }</span>
                                }
                                <span class="cov0" title="0">fmt.Println()</span>
                        }
                }

                <span class="cov0" title="0">if validCount == 0 </span><span class="cov0" title="0">{
                        fmt.Println("  No suitable interfaces found for VoIP monitoring.")
                }</span>

                <span class="cov0" title="0">fmt.Println("\nNote: Interface selection should comply with your organization's network monitoring policies.")
                fmt.Println("Only monitor interfaces you have explicit permission to access.")</span>
        },
}

func isValidMonitoringInterface(name string) bool <span class="cov8" title="1">{
        // Filter out potentially sensitive or irrelevant interfaces
        name = strings.ToLower(name)

        // Skip loopback, USB, and other non-network interfaces
        excludePatterns := []string{
                "lo", "loopback", // Loopback interfaces
                "usb", "bluetooth", // USB/Bluetooth interfaces
                "docker", "veth", // Container interfaces
                "vmnet", "vbox", // Virtual machine interfaces
                "isatap", "teredo", // Tunnel interfaces
        }

        for _, pattern := range excludePatterns </span><span class="cov8" title="1">{
                if strings.Contains(name, pattern) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

func containsSensitiveInfo(desc string) bool <span class="cov8" title="1">{
        desc = strings.ToLower(desc)
        sensitiveKeywords := []string{
                "mac", "address", "serial", "uuid",
                "hardware", "vendor", "manufacturer",
                "private", "internal", "management",
        }

        for _, keyword := range sensitiveKeywords </span><span class="cov8" title="1">{
                if strings.Contains(desc, keyword) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func sanitizeDescription(desc string) string <span class="cov8" title="1">{
        // Remove potentially sensitive information from descriptions
        desc = strings.TrimSpace(desc)

        // Keep only basic interface type descriptions
        if len(desc) &gt; 50 </span><span class="cov8" title="1">{
                desc = desc[:50] + "..."
        }</span>

        <span class="cov8" title="1">return desc</span>
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(interfacesCmd)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "fmt"
        "os"

        "github.com/endorses/lippycat/cmd/sniff"
        "github.com/endorses/lippycat/internal/pkg/logger"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var cfgFile string

var rootCmd = &amp;cobra.Command{
        Use:   "lippycat",
        Short: "lippycat sniffs for you",
        Long:  `lippycat sniffs traffic for you, including voip traffic.`,
}

func Execute() <span class="cov0" title="0">{
        err := rootCmd.Execute()
        if err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

func addSubCommandPalattes() <span class="cov8" title="1">{
        rootCmd.AddCommand(sniff.SniffCmd)
}</span>

func init() <span class="cov8" title="1">{
        cobra.OnInitialize(initConfig)

        // Initialize structured logging
        logger.Initialize()

        addSubCommandPalattes()

        rootCmd.PersistentFlags().StringVar(&amp;cfgFile, "config", "", "config file (default is $HOME/.lippycat.yaml)")

        rootCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
}</span>

func initConfig() <span class="cov0" title="0">{
        if cfgFile != "" </span><span class="cov0" title="0">{
                viper.SetConfigFile(cfgFile)
        }</span> else<span class="cov0" title="0"> {
                home, err := os.UserHomeDir()
                cobra.CheckErr(err)

                viper.AddConfigPath(home)
                viper.SetConfigType("yaml")
                viper.SetConfigName(".lippycat")
        }</span>

        <span class="cov0" title="0">viper.AutomaticEnv()

        if err := viper.ReadInConfig(); err == nil </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "Using config file:", viper.ConfigFileUsed())
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package sniff

import (
        "github.com/endorses/lippycat/internal/pkg/capture"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var SniffCmd = &amp;cobra.Command{
        Use:   "sniff",
        Short: "Start lippycat in sniff mode",
        Long:  `Start lippycat in sniff mode. Monitor the specified device`,
        Run:   sniff,
}

var (
        interfaces  string
        filter      string
        readFile    string
        writeFile   string
        promiscuous bool
)

func sniff(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        if readFile == "" </span><span class="cov0" title="0">{
                capture.StartLiveSniffer(interfaces, filter, capture.StartSniffer)
        }</span> else<span class="cov0" title="0"> {
                capture.StartOfflineSniffer(readFile, filter, capture.StartSniffer)
        }</span>
}

func init() <span class="cov8" title="1">{
        SniffCmd.AddCommand(voipCmd)
        SniffCmd.PersistentFlags().StringVarP(&amp;interfaces, "interface", "i", "any", "interface(s) to monitor, comma separated")
        SniffCmd.PersistentFlags().StringVarP(&amp;filter, "filter", "f", "", "bpf filter to apply")
        SniffCmd.PersistentFlags().StringVarP(&amp;readFile, "read-file", "r", "", "read from pcap file")
        SniffCmd.PersistentFlags().BoolVarP(&amp;promiscuous, "promiscuous", "p", false, "use promiscuous mode (captures all network traffic - use with caution)")
        SniffCmd.Flags().StringVarP(&amp;writeFile, "write-file", "w", "", "write to pcap file")

        viper.BindPFlag("promiscuous", SniffCmd.PersistentFlags().Lookup("promiscuous"))
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package sniff

import (
        "strings"
        "time"

        "github.com/endorses/lippycat/internal/pkg/logger"
        "github.com/endorses/lippycat/internal/pkg/voip"
        "github.com/endorses/lippycat/internal/pkg/voip/sipusers"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var voipCmd = &amp;cobra.Command{
        Use:   "voip",
        Short: "Sniff in VOIP mode",
        Long:  `Sniff in VOIP mode. Filter for SIP username, capture RTP stream.`,
        Run:   voipHandler,
}

var (
        sipuser   string
        writeVoip bool
)

func voipHandler(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        expirationDate := time.Date(1, 1, 1, 1, 1, 1, 1, time.UTC)
        su := sipusers.SipUser{ExpirationDate: expirationDate}

        for _, user := range strings.Split(sipuser, ",") </span><span class="cov0" title="0">{
                sipusers.AddSipUser(user, &amp;su)
        }</span>

        <span class="cov0" title="0">logger.Info("Starting VoIP sniffing",
                "users", strings.Split(sipuser, ","),
                "interfaces", interfaces,
                "write_voip", writeVoip)
        viper.Set("writeVoip", writeVoip)

        if readFile == "" </span><span class="cov0" title="0">{
                voip.StartLiveVoipSniffer(interfaces, filter)
        }</span> else<span class="cov0" title="0"> {
                voip.StartOfflineVoipSniffer(readFile, filter)
        }</span>
}

func init() <span class="cov8" title="1">{
        voipCmd.Flags().StringVarP(&amp;sipuser, "sipuser", "u", "", "SIP user to intercept")
        voipCmd.Flags().BoolVarP(&amp;writeVoip, "write-file", "w", false, "write to pcap file")
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package capture

import (
        "context"
        "runtime"
        "sync"
        "sync/atomic"
        "time"

        "github.com/endorses/lippycat/internal/pkg/capture/pcaptypes"
        "github.com/endorses/lippycat/internal/pkg/logger"
        "github.com/google/gopacket"
        "github.com/google/gopacket/layers"
        "github.com/google/gopacket/tcpassembly"
        "github.com/spf13/viper"
)

type PacketInfo struct {
        LinkType layers.LinkType
        Packet   gopacket.Packet
}

type PacketBuffer struct {
        ch         chan PacketInfo
        ctx        context.Context
        cancel     context.CancelFunc
        dropped    int64
        bufferSize int
        closed     int32 // atomic flag: 0 = open, 1 = closed
}

func NewPacketBuffer(ctx context.Context, bufferSize int) *PacketBuffer <span class="cov8" title="1">{
        ctx, cancel := context.WithCancel(ctx)
        return &amp;PacketBuffer{
                ch:         make(chan PacketInfo, bufferSize),
                ctx:        ctx,
                cancel:     cancel,
                bufferSize: bufferSize,
                closed:     0,
        }
}</span>

func (pb *PacketBuffer) Send(pkt PacketInfo) bool <span class="cov8" title="1">{
        // Check if already closed before attempting send
        if atomic.LoadInt32(&amp;pb.closed) == 1 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Use defer/recover to handle potential panic from closed channel
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        // Channel was closed during send, mark as closed
                        atomic.StoreInt32(&amp;pb.closed, 1)
                }</span>
        }()

        // Check context first to ensure consistent behavior
        <span class="cov8" title="1">select </span>{
        case &lt;-pb.ctx.Done():<span class="cov8" title="1">
                return false</span>
        default:<span class="cov8" title="1"></span>
        }

        <span class="cov8" title="1">select </span>{
        case pb.ch &lt;- pkt:<span class="cov8" title="1">
                return true</span>
        case &lt;-pb.ctx.Done():<span class="cov0" title="0">
                return false</span>
        default:<span class="cov8" title="1">
                // Non-blocking send with drop counting
                atomic.AddInt64(&amp;pb.dropped, 1)
                if atomic.LoadInt64(&amp;pb.dropped)%1000 == 0 </span><span class="cov8" title="1">{
                        logger.Warn("Packets dropped due to buffer overflow",
                                "total_dropped", atomic.LoadInt64(&amp;pb.dropped))
                }</span>
                <span class="cov8" title="1">return false</span>
        }
}

func (pb *PacketBuffer) Receive() &lt;-chan PacketInfo <span class="cov8" title="1">{
        return pb.ch
}</span>

func (pb *PacketBuffer) Close() <span class="cov8" title="1">{
        // Set closed flag atomically before closing channel
        if !atomic.CompareAndSwapInt32(&amp;pb.closed, 0, 1) </span><span class="cov8" title="1">{
                // Already closed, return early
                return
        }</span>

        <span class="cov8" title="1">pb.cancel()

        // Give senders a small window to finish
        time.Sleep(10 * time.Millisecond)

        close(pb.ch)
        if dropped := atomic.LoadInt64(&amp;pb.dropped); dropped &gt; 0 </span><span class="cov8" title="1">{
                logger.Info("Packet buffer closed with drops",
                        "total_dropped", dropped)
        }</span>
}

func (pb *PacketBuffer) IsClosed() bool <span class="cov8" title="1">{
        return atomic.LoadInt32(&amp;pb.closed) == 1
}</span>

func Init(ifaces []pcaptypes.PcapInterface, filter string, packetProcessor func(ch &lt;-chan PacketInfo, assembler *tcpassembly.Assembler), assembler *tcpassembly.Assembler) <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Use a configurable buffer size with proper backpressure handling
        bufferSize := getPacketBufferSize()
        packetBuffer := NewPacketBuffer(ctx, bufferSize)
        defer packetBuffer.Close()

        var wg sync.WaitGroup
        var processorWg sync.WaitGroup
        numProcessors := runtime.NumCPU()
        processorWg.Add(numProcessors)

        for _, iface := range ifaces </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(pif pcaptypes.PcapInterface) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        err := pif.SetHandle()
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("Error setting pcap handle",
                                        "error", err,
                                        "interface", pif.Name())
                                return
                        }</span>
                        <span class="cov0" title="0">handle, err := pif.Handle()
                        if err != nil || handle == nil </span><span class="cov0" title="0">{
                                logger.Error("Error getting pcap handle",
                                        "error", err,
                                        "interface", pif.Name())
                                return
                        }</span>
                        <span class="cov0" title="0">defer handle.Close()
                        captureFromInterface(ctx, pif, filter, packetBuffer)</span>
                }(iface)
        }

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        // Context cancelled, force cleanup
                        packetBuffer.Close()</span>
                default:<span class="cov0" title="0">
                        wg.Wait()
                        packetBuffer.Close()</span>
                }
        }()

        <span class="cov0" title="0">for range numProcessors </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        defer processorWg.Done()
                        // Create a context-aware packet processor that can be cancelled
                        for </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                default:<span class="cov0" title="0">
                                        // Run packet processor with context monitoring
                                        packetProcessor(packetBuffer.Receive(), assembler)
                                        // Check if buffer is closed
                                        if packetBuffer.IsClosed() </span><span class="cov0" title="0">{
                                                return
                                        }</span>
                                }
                        }
                }()
        }

        <span class="cov0" title="0">processorWg.Wait()</span>
}

func captureFromInterface(ctx context.Context, iface pcaptypes.PcapInterface, filter string, buffer *PacketBuffer) <span class="cov0" title="0">{
        handle, err := iface.Handle()
        if err != nil || handle == nil </span><span class="cov0" title="0">{
                logger.Error("Unable to get interface handle",
                        "error", err,
                        "interface", iface.Name())
                return
        }</span>
        <span class="cov0" title="0">filterErr := handle.SetBPFFilter(filter)
        if filterErr != nil </span><span class="cov0" title="0">{
                logger.Error("Error setting BPF filter",
                        "filter", filter,
                        "error", filterErr,
                        "interface", iface.Name())
                return
        }</span>
        <span class="cov0" title="0">packetSource := gopacket.NewPacketSource(handle, handle.LinkType())

        // Add periodic stats logging
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()

        packetCount := int64(0)
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                count := atomic.LoadInt64(&amp;packetCount)
                                dropped := atomic.LoadInt64(&amp;buffer.dropped)
                                logger.Info("Interface packet statistics",
                                        "interface", iface.Name(),
                                        "packets_processed", count,
                                        "packets_dropped", dropped)</span>
                        }
                }
        }()

        <span class="cov0" title="0">for packet := range packetSource.Packets() </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        pktInfo := PacketInfo{
                                LinkType: handle.LinkType(),
                                Packet:   packet,
                        }
                        buffer.Send(pktInfo)
                        atomic.AddInt64(&amp;packetCount, 1)</span>
                }
        }
}

// getPacketBufferSize returns the configured packet buffer size
// Default is 10000 packets, but can be overridden via configuration
func getPacketBufferSize() int <span class="cov8" title="1">{
        const defaultBufferSize = DefaultPacketBufferSize

        // Check for configuration via viper (environment variables, config files, etc.)
        if viper.IsSet("packet_buffer_size") </span><span class="cov8" title="1">{
                size := viper.GetInt("packet_buffer_size")
                if size &gt; 0 </span><span class="cov8" title="1">{
                        return size
                }</span>
        }

        // Fall back to default
        <span class="cov8" title="1">return defaultBufferSize</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package pcaptypes

import (
        "errors"

        "github.com/google/gopacket/pcap"
        "github.com/spf13/viper"
)

type liveInterface struct {
        Device string
        handle *pcap.Handle
}

func (iface *liveInterface) SetHandle() error <span class="cov8" title="1">{
        // Close existing handle if it exists to prevent leaks
        if iface.handle != nil </span><span class="cov0" title="0">{
                iface.handle.Close()
                iface.handle = nil
        }</span>

        <span class="cov8" title="1">promiscuous := viper.GetViper().GetBool("promiscuous")
        snapshotLen := int32(MaxPcapSnapshotLen)
        timeout := pcap.BlockForever
        handle, err := pcap.OpenLive(iface.Device, snapshotLen, promiscuous, timeout)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov0" title="0">iface.handle = handle
        return nil</span>
}

func (iface liveInterface) Handle() (*pcap.Handle, error) <span class="cov8" title="1">{
        var err error
        if iface.handle == nil </span><span class="cov8" title="1">{
                err = errors.New("interface has no handle")
        }</span>
        <span class="cov8" title="1">return iface.handle, err</span>
}

func (iface liveInterface) Name() string <span class="cov8" title="1">{
        return iface.Device
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package pcaptypes

import (
        "errors"
        "os"

        "github.com/google/gopacket/pcap"
)

type offlineInterface struct {
        file   *os.File
        handle *pcap.Handle
}

func (iface *offlineInterface) SetHandle() error <span class="cov8" title="1">{
        handle, err := pcap.OpenOfflineFile(iface.file)
        iface.handle = handle
        return err
}</span>

func (iface offlineInterface) Handle() (*pcap.Handle, error) <span class="cov8" title="1">{
        var err error
        if iface.handle == nil </span><span class="cov8" title="1">{
                err = errors.New("Interface has no handle")
        }</span>
        <span class="cov8" title="1">return iface.handle, err</span>
}

func (iface offlineInterface) Name() string <span class="cov8" title="1">{
        if iface.file != nil </span><span class="cov8" title="1">{
                return iface.file.Name()
        }</span>
        <span class="cov8" title="1">return "offline"</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package pcaptypes

import (
        "os"

        "github.com/google/gopacket/pcap"
)

type PcapInterface interface {
        SetHandle() error
        Handle() (*pcap.Handle, error)
        Name() string
}

func CreateLiveInterface(device string) PcapInterface <span class="cov8" title="1">{
        var result PcapInterface
        iface := liveInterface{device, nil}
        result = PcapInterface(&amp;iface)
        return result
}</span>

func CreateOfflineInterface(f *os.File) PcapInterface <span class="cov8" title="1">{
        var result PcapInterface
        iface := offlineInterface{f, nil}
        result = PcapInterface(&amp;iface)
        return result
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package capture

import (
        "context"
        "fmt"
        "io"
        "os"
        "strings"
        "sync"
        "time"

        "github.com/endorses/lippycat/internal/pkg/capture/pcaptypes"
        "github.com/endorses/lippycat/internal/pkg/logger"
        "github.com/google/gopacket"
        "github.com/google/gopacket/layers"
        "github.com/google/gopacket/tcpassembly"
        "github.com/google/gopacket/tcpassembly/tcpreader"
)

func StartLiveSniffer(interfaces, filter string, startSniffer func(devices []pcaptypes.PcapInterface, filter string)) <span class="cov8" title="1">{
        var devices []pcaptypes.PcapInterface
        for _, device := range strings.Split(interfaces, ",") </span><span class="cov8" title="1">{
                iface := pcaptypes.CreateLiveInterface(device)
                devices = append(devices, iface)
        }</span>
        <span class="cov8" title="1">startSniffer(devices, filter)</span>
}

func StartOfflineSniffer(readFile, filter string, startSniffer func(devices []pcaptypes.PcapInterface, filter string)) <span class="cov8" title="1">{
        file, err := os.Open(readFile)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Could not read file",
                        "file", readFile,
                        "error", err)
                return
        }</span>

        // Create a context with timeout to prevent indefinite blocking
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
        defer cancel()

        // Ensure file is always closed, even if startSniffer blocks
        defer file.Close()

        iface := pcaptypes.CreateOfflineInterface(file)
        devices := []pcaptypes.PcapInterface{iface}

        // Run startSniffer in a goroutine with context monitoring
        done := make(chan struct{})
        go func() </span><span class="cov8" title="1">{
                defer close(done)
                startSniffer(devices, filter)
        }</span>()

        // Wait for completion or timeout
        <span class="cov8" title="1">select </span>{
        case &lt;-done:<span class="cov8" title="1"></span>
                // Completed normally
        case &lt;-ctx.Done():<span class="cov0" title="0">
                logger.Error("Offline sniffer timed out, forcing cleanup",
                        "file", readFile,
                        "error", ctx.Err())</span>
        }
}

func StartSniffer(devices []pcaptypes.PcapInterface, filter string) <span class="cov0" title="0">{
        fmt.Println("Starting Sniffer")
        streamFactory := NewStreamFactory()
        streamPool := tcpassembly.NewStreamPool(streamFactory)
        assembler := tcpassembly.NewAssembler(streamPool)
        Init(devices, filter, processPacket, assembler)
}</span>

const maxStreamWorkers = 50 // Maximum concurrent stream processing goroutines

type streamFactory struct {
        workerPool chan struct{}
        wg         sync.WaitGroup
}

func NewStreamFactory() tcpassembly.StreamFactory <span class="cov0" title="0">{
        return &amp;streamFactory{
                workerPool: make(chan struct{}, maxStreamWorkers),
        }
}</span>

func (f *streamFactory) New(net, transport gopacket.Flow) tcpassembly.Stream <span class="cov0" title="0">{
        r := tcpreader.NewReaderStream()

        // Try to acquire a worker from the pool (non-blocking)
        select </span>{
        case f.workerPool &lt;- struct{}{}:<span class="cov0" title="0">
                // Got a worker slot, start processing
                f.wg.Add(1)
                go f.processStreamWithPool(&amp;r)</span>
        default:<span class="cov0" title="0">
                // Pool is full, log and skip processing to prevent goroutine explosion
                logger.Warn("Stream worker pool exhausted, skipping stream processing",
                        "max_workers", maxStreamWorkers)</span>
        }

        <span class="cov0" title="0">return &amp;r</span>
}

func (f *streamFactory) processStreamWithPool(r io.Reader) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                // Release worker slot back to pool
                &lt;-f.workerPool
                f.wg.Done()

                if rec := recover(); rec != nil </span><span class="cov0" title="0">{
                        logger.Error("Stream processing panic recovered",
                                "panic_value", rec)
                }</span>
        }()

        <span class="cov0" title="0">processStream(r)</span>
}

// Shutdown waits for all active stream workers to complete
func (f *streamFactory) Shutdown() <span class="cov0" title="0">{
        f.wg.Wait()
}</span>

func processStream(r io.Reader) <span class="cov8" title="1">{
        // Process the stream data properly
        buffer := make([]byte, 4096)
        for </span><span class="cov8" title="1">{
                n, err := r.Read(buffer)
                if err != nil </span><span class="cov8" title="1">{
                        if err != io.EOF </span><span class="cov8" title="1">{
                                logger.Error("Error reading stream", "error", err)
                        }</span>
                        <span class="cov8" title="1">return</span>
                }
                <span class="cov8" title="1">if n == 0 </span><span class="cov0" title="0">{
                        return
                }</span>

                // Process the data (this is a placeholder - real processing would depend on protocol)
                <span class="cov8" title="1">data := buffer[:n]
                if len(data) &gt; 0 </span><span class="cov8" title="1">{
                        logger.Debug("Processed bytes from stream",
                                "bytes_count", len(data))
                        // Here you would implement actual protocol parsing
                }</span>
        }
}

func processPacket(packetChan &lt;-chan PacketInfo, assembler *tcpassembly.Assembler) <span class="cov0" title="0">{
        for p := range packetChan </span><span class="cov0" title="0">{
                packet := p.Packet
                switch layer := packet.TransportLayer().(type) </span>{
                case *layers.TCP:<span class="cov0" title="0">
                        // fmt.Println("TCP")
                        assembler.AssembleWithTimestamp(
                                packet.NetworkLayer().NetworkFlow(),
                                layer,
                                packet.Metadata().Timestamp,
                        )</span>
                case *layers.UDP:<span class="cov0" title="0"></span>
                        // fmt.Println("UDP")
                }
                <span class="cov0" title="0">fmt.Printf("%s\n", p.Packet)</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package logger

import (
        "context"
        "log/slog"
        "os"
        "sync"
)

var (
        defaultLogger *slog.Logger
        once          sync.Once
)

// Initialize sets up the structured logger
func Initialize() <span class="cov8" title="1">{
        once.Do(func() </span><span class="cov8" title="1">{
                // Create a JSON handler for production use
                handler := slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                        Level:     slog.LevelInfo,
                        AddSource: true,
                })
                defaultLogger = slog.New(handler)
        }</span>)
}

// Get returns the default structured logger
func Get() *slog.Logger <span class="cov8" title="1">{
        Initialize() // Always call Initialize, sync.Once ensures it only runs once
        return defaultLogger
}</span>

// Info logs an info level message
func Info(msg string, args ...any) <span class="cov8" title="1">{
        Get().Info(msg, args...)
}</span>

// InfoContext logs an info level message with context
func InfoContext(ctx context.Context, msg string, args ...any) <span class="cov8" title="1">{
        Get().InfoContext(ctx, msg, args...)
}</span>

// Warn logs a warning level message
func Warn(msg string, args ...any) <span class="cov8" title="1">{
        Get().Warn(msg, args...)
}</span>

// WarnContext logs a warning level message with context
func WarnContext(ctx context.Context, msg string, args ...any) <span class="cov8" title="1">{
        Get().WarnContext(ctx, msg, args...)
}</span>

// Error logs an error level message
func Error(msg string, args ...any) <span class="cov8" title="1">{
        Get().Error(msg, args...)
}</span>

// ErrorContext logs an error level message with context
func ErrorContext(ctx context.Context, msg string, args ...any) <span class="cov8" title="1">{
        Get().ErrorContext(ctx, msg, args...)
}</span>

// Debug logs a debug level message
func Debug(msg string, args ...any) <span class="cov8" title="1">{
        Get().Debug(msg, args...)
}</span>

// DebugContext logs a debug level message with context
func DebugContext(ctx context.Context, msg string, args ...any) <span class="cov8" title="1">{
        Get().DebugContext(ctx, msg, args...)
}</span>

// With returns a logger with the given attributes
func With(args ...any) *slog.Logger <span class="cov8" title="1">{
        return Get().With(args...)
}</span>

// WithGroup returns a logger with the given group name
func WithGroup(name string) *slog.Logger <span class="cov8" title="1">{
        return Get().WithGroup(name)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package voip

import (
        "context"
        "errors"
        "fmt"
        "os"
        "os/signal"
        "path/filepath"
        "strings"
        "sync"
        "syscall"
        "time"
        "unicode"
        "unicode/utf8"

        "github.com/endorses/lippycat/internal/pkg/capture/pcaptypes"
        "github.com/endorses/lippycat/internal/pkg/logger"
        "github.com/google/gopacket/layers"
        "github.com/google/gopacket/pcapgo"
        "github.com/spf13/viper"
)

type CallInfo struct {
        CallID      string
        State       string
        Created     time.Time
        LastUpdated time.Time
        LinkType    layers.LinkType
        SIPWriter   *pcapgo.Writer
        RTPWriter   *pcapgo.Writer
        sipFile     *os.File
        rtpFile     *os.File
}

type CallTracker struct {
        callMap           map[string]*CallInfo
        portToCallID      map[string]string // key = port, value = CallID
        mu                sync.RWMutex
        janitorCtx        context.Context
        janitorCancel     context.CancelFunc
        janitorStarted    bool
        shutdownOnce      sync.Once
        signalHandlerOnce sync.Once
        config            *Config
}

var (
        defaultTracker *CallTracker
        trackerOnce    sync.Once
)

func getTracker() *CallTracker <span class="cov8" title="1">{
        trackerOnce.Do(func() </span><span class="cov8" title="1">{
                defaultTracker = NewCallTracker()
        }</span>)
        <span class="cov8" title="1">return defaultTracker</span>
}

func NewCallTracker() *CallTracker <span class="cov8" title="1">{
        ctx, cancel := context.WithCancel(context.Background())
        tracker := &amp;CallTracker{
                callMap:        make(map[string]*CallInfo),
                portToCallID:   make(map[string]string),
                janitorCtx:     ctx,
                janitorCancel:  cancel,
                janitorStarted: false,
                config:         GetConfig(),
        }

        tracker.startJanitor()

        // Set up automatic cleanup on process termination
        go tracker.setupSignalHandler()

        return tracker
}</span>

func (ct *CallTracker) startJanitor() <span class="cov8" title="1">{
        ct.mu.Lock()
        defer ct.mu.Unlock()

        if !ct.janitorStarted </span><span class="cov8" title="1">{
                go ct.janitorLoop()
                ct.janitorStarted = true
        }</span>
}

// setupSignalHandler handles cleanup on process termination
func (ct *CallTracker) setupSignalHandler() <span class="cov8" title="1">{
        ct.signalHandlerOnce.Do(func() </span><span class="cov8" title="1">{
                sigCh := make(chan os.Signal, 1)
                signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM, syscall.SIGHUP)

                go func() </span><span class="cov8" title="1">{
                        &lt;-sigCh // Block until we receive a signal
                        ct.Shutdown()
                }</span>()
        })
}

// Shutdown gracefully shuts down the call tracker
func (ct *CallTracker) Shutdown() <span class="cov8" title="1">{
        ct.shutdownOnce.Do(func() </span><span class="cov8" title="1">{
                if ct.janitorCancel != nil </span><span class="cov8" title="1">{
                        ct.janitorCancel()
                }</span>
                // Close all open call files
                <span class="cov8" title="1">ct.mu.Lock()
                for id, call := range ct.callMap </span><span class="cov8" title="1">{
                        if call.sipFile != nil </span><span class="cov0" title="0">{
                                call.sipFile.Close()
                        }</span>
                        <span class="cov8" title="1">if call.rtpFile != nil </span><span class="cov0" title="0">{
                                call.rtpFile.Close()
                        }</span>
                        <span class="cov8" title="1">delete(ct.callMap, id)</span>
                }
                <span class="cov8" title="1">ct.mu.Unlock()</span>
        })
}

// ShutdownCallTracker gracefully shuts down the default call tracker
func ShutdownCallTracker() <span class="cov8" title="1">{
        getTracker().Shutdown()
}</span>

func (c *CallInfo) SetCallInfoState(newState string) <span class="cov8" title="1">{
        tracker := getTracker()
        tracker.mu.Lock()
        defer tracker.mu.Unlock()

        c.State = newState
        c.LastUpdated = time.Now()
}</span>

func getCall(callID string) (*CallInfo, error) <span class="cov8" title="1">{
        tracker := getTracker()
        tracker.mu.RLock()
        defer tracker.mu.RUnlock()

        result, exists := tracker.callMap[callID]
        if !exists </span><span class="cov8" title="1">{
                return nil, errors.New("the CallID does not exist")
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

func GetOrCreateCall(callID string, linkType layers.LinkType) *CallInfo <span class="cov8" title="1">{
        tracker := getTracker()
        tracker.mu.Lock()
        defer tracker.mu.Unlock()

        call, exists := tracker.callMap[callID]
        if !exists </span><span class="cov8" title="1">{
                call = &amp;CallInfo{
                        CallID:      callID,
                        State:       "NEW",
                        Created:     time.Now(),
                        LastUpdated: time.Now(),
                        LinkType:    linkType,
                }
                if viper.GetViper().GetBool("writeVoip") </span><span class="cov0" title="0">{
                        if err := call.initWriters(); err != nil </span><span class="cov0" title="0">{
                                logger.Error("Failed to initialize writers for call",
                                        "call_id", callID,
                                        "error", err)
                                // Don't track call if we can't write it - prevents silent data loss
                                return nil
                        }</span>
                }
                <span class="cov8" title="1">tracker.callMap[callID] = call</span>
        }
        <span class="cov8" title="1">return call</span>
}

func (c *CallInfo) initWriters() error <span class="cov8" title="1">{
        if err := os.MkdirAll("captures", 0o755); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create captures directory: %w", err)
        }</span>

        <span class="cov8" title="1">sipPath := filepath.Join("captures", fmt.Sprintf("sip_%s.pcap", sanitize(c.CallID)))
        rtpPath := filepath.Join("captures", fmt.Sprintf("rtp_%s.pcap", sanitize(c.CallID)))

        var err error
        c.sipFile, err = os.Create(sipPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create SIP file %s: %w", sipPath, err)
        }</span>

        <span class="cov8" title="1">c.rtpFile, err = os.Create(rtpPath)
        if err != nil </span><span class="cov0" title="0">{
                if c.sipFile != nil </span><span class="cov0" title="0">{
                        c.sipFile.Close()
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to create RTP file %s: %w", rtpPath, err)</span>
        }

        <span class="cov8" title="1">c.SIPWriter = pcapgo.NewWriter(c.sipFile)
        c.RTPWriter = pcapgo.NewWriter(c.rtpFile)

        if err := c.SIPWriter.WriteFileHeader(pcaptypes.MaxPcapSnapshotLen, c.LinkType); err != nil </span><span class="cov0" title="0">{
                c.sipFile.Close()
                c.rtpFile.Close()
                return fmt.Errorf("failed to write SIP file header: %w", err)
        }</span>

        <span class="cov8" title="1">if err := c.RTPWriter.WriteFileHeader(pcaptypes.MaxPcapSnapshotLen, c.LinkType); err != nil </span><span class="cov0" title="0">{
                c.sipFile.Close()
                c.rtpFile.Close()
                return fmt.Errorf("failed to write RTP file header: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func sanitize(id string) string <span class="cov8" title="1">{
        // Handle empty string case
        if id == "" </span><span class="cov8" title="1">{
                return "safe_filename"
        }</span>

        // Normalize Unicode to prevent normalization attacks
        <span class="cov8" title="1">cleaned := normalizeUnicode(id)

        // Iteratively clean dangerous patterns until no more changes occur
        maxIterations := 10 // Prevent infinite loops
        for i := 0; i &lt; maxIterations; i++ </span><span class="cov8" title="1">{
                previous := cleaned

                // Replace ".." sequences first (before individual dots)
                cleaned = strings.ReplaceAll(cleaned, "..", "__")

                // Replace potentially dangerous characters
                cleaned = strings.ReplaceAll(cleaned, "\\", "_")
                cleaned = strings.ReplaceAll(cleaned, "/", "_")
                cleaned = strings.ReplaceAll(cleaned, "@", "_")
                cleaned = strings.ReplaceAll(cleaned, ":", "_")
                cleaned = strings.ReplaceAll(cleaned, "*", "_")
                cleaned = strings.ReplaceAll(cleaned, "?", "_")
                cleaned = strings.ReplaceAll(cleaned, "&lt;", "_")
                cleaned = strings.ReplaceAll(cleaned, "&gt;", "_")
                cleaned = strings.ReplaceAll(cleaned, "|", "_")
                cleaned = strings.ReplaceAll(cleaned, "\"", "_")

                // If no changes were made, we're done
                if cleaned == previous </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        // Remove null bytes and other control characters
        <span class="cov8" title="1">cleaned = removeControlCharacters(cleaned)

        // Limit length to prevent filesystem issues (configurable)
        maxLen := GetConfig().MaxFilenameLength
        if len(cleaned) &gt; maxLen </span><span class="cov8" title="1">{
                cleaned = cleaned[:maxLen]
        }</span>

        // Apply filepath.Clean for additional security
        <span class="cov8" title="1">cleaned = filepath.Clean(cleaned)

        // If cleaning resulted in empty string or dangerous paths, use safe default
        if cleaned == "" || cleaned == "." || cleaned == ".." || strings.Contains(cleaned, "..") </span><span class="cov8" title="1">{
                return "safe_filename"
        }</span>

        <span class="cov8" title="1">return cleaned</span>
}

// normalizeUnicode normalizes unicode strings to prevent normalization attacks
func normalizeUnicode(s string) string <span class="cov8" title="1">{
        if !utf8.ValidString(s) </span><span class="cov0" title="0">{
                // Replace invalid UTF-8 sequences
                return strings.ToValidUTF8(s, "_")
        }</span>

        // Normalize to NFC (Canonical Decomposition, followed by Canonical Composition)
        // This prevents attacks using different unicode representations of the same string
        <span class="cov8" title="1">var normalized strings.Builder
        for _, r := range s </span><span class="cov8" title="1">{
                // Skip non-printable characters except common whitespace
                if unicode.IsPrint(r) || r == ' ' || r == '\t' </span><span class="cov8" title="1">{
                        normalized.WriteRune(r)
                }</span> else<span class="cov8" title="1"> {
                        normalized.WriteString("_")
                }</span>
        }

        <span class="cov8" title="1">return normalized.String()</span>
}

// removeControlCharacters removes control characters that could be dangerous in filenames
func removeControlCharacters(s string) string <span class="cov8" title="1">{
        var cleaned strings.Builder
        for _, r := range s </span><span class="cov8" title="1">{
                // Keep printable characters and safe whitespace
                if unicode.IsPrint(r) || r == ' ' </span><span class="cov8" title="1">{
                        cleaned.WriteRune(r)
                }</span> else<span class="cov0" title="0"> {
                        cleaned.WriteString("_")
                }</span>
        }
        <span class="cov8" title="1">return cleaned.String()</span>
}

func (ct *CallTracker) janitorLoop() <span class="cov8" title="1">{
        ticker := time.NewTicker(ct.config.JanitorCleanupInterval)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ct.janitorCtx.Done():<span class="cov8" title="1">
                        logger.Info("Call tracker janitor shutting down")
                        return</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        ct.cleanupOldCalls()</span>
                }
        }
}

func (ct *CallTracker) cleanupOldCalls() <span class="cov8" title="1">{
        ct.mu.Lock()
        defer ct.mu.Unlock()

        expireAfter := ct.config.CallExpirationTime
        now := time.Now()

        for id, call := range ct.callMap </span><span class="cov8" title="1">{
                if now.Sub(call.LastUpdated) &gt; expireAfter </span><span class="cov8" title="1">{
                        logger.Info("Cleaning up expired call",
                                "call_id", id,
                                "last_updated", call.LastUpdated,
                                "age_seconds", int(now.Sub(call.LastUpdated).Seconds()))
                        if call.sipFile != nil </span><span class="cov0" title="0">{
                                if err := call.sipFile.Close(); err != nil </span><span class="cov0" title="0">{
                                        logger.Error("Error closing SIP file for call",
                                                "call_id", id,
                                                "error", err)
                                }</span>
                        }
                        <span class="cov8" title="1">if call.rtpFile != nil </span><span class="cov0" title="0">{
                                if err := call.rtpFile.Close(); err != nil </span><span class="cov0" title="0">{
                                        logger.Error("Error closing RTP file for call",
                                                "call_id", id,
                                                "error", err)
                                }</span>
                        }
                        <span class="cov8" title="1">delete(ct.callMap, id)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package voip

import (
        "sync"
        "time"

        "github.com/spf13/viper"
)

var configOnce sync.Once

// Config holds all configurable VoIP processing parameters
type Config struct {
        // Goroutine limits
        MaxGoroutines int `mapstructure:"max_goroutines"`

        // Timeout configurations
        CallIDDetectionTimeout time.Duration `mapstructure:"call_id_detection_timeout"`
        JanitorCleanupInterval time.Duration `mapstructure:"janitor_cleanup_interval"`
        CallExpirationTime     time.Duration `mapstructure:"call_expiration_time"`

        // Buffer configurations
        StreamQueueBuffer int `mapstructure:"stream_queue_buffer"`

        // File handling
        MaxFilenameLength int `mapstructure:"max_filename_length"`

        // Logging
        LogGoroutineLimitInterval time.Duration `mapstructure:"log_goroutine_limit_interval"`
}

// initConfigDefaults initializes viper defaults once
func initConfigDefaults() <span class="cov8" title="1">{
        viper.SetDefault("voip.max_goroutines", DefaultGoroutineLimit)
        viper.SetDefault("voip.call_id_detection_timeout", DefaultCallIDDetectionTimeout)
        viper.SetDefault("voip.janitor_cleanup_interval", DefaultJanitorCleanupInterval)
        viper.SetDefault("voip.call_expiration_time", DefaultCallExpirationTime)
        viper.SetDefault("voip.stream_queue_buffer", DefaultStreamQueueBuffer)
        viper.SetDefault("voip.max_filename_length", 100)
        viper.SetDefault("voip.log_goroutine_limit_interval", 30*time.Second)
}</span>

// GetConfig returns the current VoIP configuration with defaults
func GetConfig() *Config <span class="cov8" title="1">{
        // Initialize defaults only once to prevent race conditions
        configOnce.Do(initConfigDefaults)

        config := &amp;Config{
                MaxGoroutines:             viper.GetInt("voip.max_goroutines"),
                CallIDDetectionTimeout:    viper.GetDuration("voip.call_id_detection_timeout"),
                JanitorCleanupInterval:    viper.GetDuration("voip.janitor_cleanup_interval"),
                CallExpirationTime:        viper.GetDuration("voip.call_expiration_time"),
                StreamQueueBuffer:         viper.GetInt("voip.stream_queue_buffer"),
                MaxFilenameLength:         viper.GetInt("voip.max_filename_length"),
                LogGoroutineLimitInterval: viper.GetDuration("voip.log_goroutine_limit_interval"),
        }

        return config
}</pre>
		
		<pre class="file" id="file12" style="display: none">package voip

import (
        "context"

        "github.com/endorses/lippycat/internal/pkg/capture"
        "github.com/endorses/lippycat/internal/pkg/capture/pcaptypes"
        "github.com/endorses/lippycat/internal/pkg/logger"
        "github.com/endorses/lippycat/internal/pkg/voip/sipusers"
        "github.com/google/gopacket/layers"
        "github.com/google/gopacket/tcpassembly"
)

func StartVoipSniffer(devices []pcaptypes.PcapInterface, filter string) <span class="cov8" title="1">{
        ctx := context.Background()
        logger.InfoContext(ctx, "Starting VoIP sniffer",
                "device_count", len(devices),
                "filter", filter)

        streamFactory := NewSipStreamFactory(ctx)
        streamPool := tcpassembly.NewStreamPool(streamFactory)
        assembler := tcpassembly.NewAssembler(streamPool)
        capture.Init(devices, filter, startProcessor, assembler)
}</span>

func StartLiveVoipSniffer(interfaces, filter string) <span class="cov8" title="1">{
        capture.StartLiveSniffer(interfaces, filter, StartVoipSniffer)
}</span>

func StartOfflineVoipSniffer(interfaces, filter string) <span class="cov8" title="1">{
        capture.StartOfflineSniffer(interfaces, filter, StartVoipSniffer)
}</span>

func startProcessor(ch &lt;-chan capture.PacketInfo, assembler *tcpassembly.Assembler) <span class="cov8" title="1">{
        defer CloseWriters()
        // fmt.Println("Starting Processor")
        for pkt := range ch </span><span class="cov8" title="1">{
                packet := pkt.Packet
                if packet.NetworkLayer() == nil || packet.TransportLayer() == nil </span><span class="cov8" title="1">{
                        // fmt.Println("startProcessor nil")
                        continue</span>
                }
                <span class="cov8" title="1">switch layer := packet.TransportLayer().(type) </span>{
                case *layers.TCP:<span class="cov8" title="1">
                        // fmt.Println("TCP")
                        handleTcpPackets(pkt, layer, assembler)</span>
                case *layers.UDP:<span class="cov8" title="1">
                        // fmt.Println("UDP")
                        handleUdpPackets(pkt, layer)</span>
                }
        }
}

func containsUserInHeaders(headers map[string]string) bool <span class="cov8" title="1">{
        for _, field := range []string{"from", "to", "p-asserted-identity"} </span><span class="cov8" title="1">{
                val := headers[field]
                if sipusers.IsSurveiled(val) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package voip

import (
        "strconv"
        "strings"

        "github.com/endorses/lippycat/internal/pkg/logger"
        "github.com/google/gopacket"
)

// portToCallID is now managed by the CallTracker

func ExtractPortFromSdp(line string, callID string) <span class="cov8" title="1">{
        _, partThatContainsPort, hasPort := strings.Cut(line, "m=audio")
        if !hasPort </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">parts := strings.Fields(partThatContainsPort)
        if len(parts) &gt;= 1 </span><span class="cov8" title="1">{
                port := strings.TrimSpace(parts[0])

                // Validate port number to prevent integer overflow and invalid mappings
                if !isValidPort(port) </span><span class="cov8" title="1">{
                        logger.Debug("Invalid port number in SDP",
                                "port", port,
                                "call_id", callID)
                        return
                }</span>

                <span class="cov8" title="1">tracker := getTracker()
                tracker.mu.Lock()
                defer tracker.mu.Unlock()
                tracker.portToCallID[port] = callID</span>
        }
}

func IsTracked(packet gopacket.Packet) bool <span class="cov8" title="1">{
        transportLayer := packet.TransportLayer()
        if transportLayer == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">dst := transportLayer.TransportFlow().Dst().String()
        src := transportLayer.TransportFlow().Src().String()
        tracker := getTracker()
        tracker.mu.RLock()
        defer tracker.mu.RUnlock()
        _, dstOk := tracker.portToCallID[dst]
        _, srcOk := tracker.portToCallID[src]
        return dstOk || srcOk</span>
}

func GetCallIDForPacket(packet gopacket.Packet) string <span class="cov8" title="1">{
        transportLayer := packet.TransportLayer()
        if transportLayer == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">dst := transportLayer.TransportFlow().Dst().String()
        src := transportLayer.TransportFlow().Src().String()
        tracker := getTracker()
        tracker.mu.RLock()
        defer tracker.mu.RUnlock()

        // Check both destination and source ports
        if callID, ok := tracker.portToCallID[dst]; ok </span><span class="cov8" title="1">{
                return callID
        }</span>
        <span class="cov8" title="1">if callID, ok := tracker.portToCallID[src]; ok </span><span class="cov8" title="1">{
                return callID
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// isValidPort validates that a string represents a valid UDP/TCP port number
func isValidPort(portStr string) bool <span class="cov8" title="1">{
        if portStr == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        // Parse as integer to validate format and range
        <span class="cov8" title="1">port, err := strconv.Atoi(portStr)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // Valid port range is 1-65535 (0 is reserved)
        <span class="cov8" title="1">if port &lt; 1 || port &gt; 65535 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package voip

import (
        "bytes"
        "strings"

        "github.com/endorses/lippycat/internal/pkg/logger"
)

func handleSipMessage(data []byte) bool <span class="cov8" title="1">{
        lines := bytes.Split(data, []byte("\n"))
        if len(lines) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">startLine := strings.TrimSpace(string(lines[0]))
        if !isSipStartLine(startLine) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">headers, body := parseSipHeaders(data)

        if containsUserInHeaders(headers) </span><span class="cov8" title="1">{
                callID := headers["call-id"]
                if callID != "" </span><span class="cov8" title="1">{
                        if strings.Contains(body, "m=audio") </span><span class="cov8" title="1">{
                                method := detectSipMethod(startLine)
                                call, err := getCall(callID)
                                if err == nil </span><span class="cov8" title="1">{
                                        call.SetCallInfoState(method)
                                }</span>
                                // fmt.Println("extracting Port for callid", callID)
                                <span class="cov8" title="1">ExtractPortFromSdp(body, callID)</span>
                        }
                }
                <span class="cov8" title="1">return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

func detectSipMethod(line string) string <span class="cov8" title="1">{
        if strings.HasPrefix(line, "INVITE") </span><span class="cov8" title="1">{
                return "INVITE"
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(line, "REGISTER") </span><span class="cov8" title="1">{
                return "REGISTER"
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(line, "BYE") </span><span class="cov8" title="1">{
                return "BYE"
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(line, "CANCEL") </span><span class="cov8" title="1">{
                return "CANCEL"
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(line, "ACK") </span><span class="cov8" title="1">{
                return "ACK"
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(line, "OPTIONS") </span><span class="cov8" title="1">{
                return "OPTIONS"
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(line, "SIP/2.0") </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return ""</span>
}

func isSipStartLine(line string) bool <span class="cov8" title="1">{
        // SIP responses start with SIP/2.0
        if strings.HasPrefix(line, "SIP/2.0") </span><span class="cov8" title="1">{
                return true
        }</span>

        // SIP requests must contain "SIP/2.0" at the end
        <span class="cov8" title="1">if !strings.Contains(line, "SIP/2.0") </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check for valid SIP methods at the beginning
        <span class="cov8" title="1">return strings.HasPrefix(line, "INVITE ") ||
                strings.HasPrefix(line, "BYE ") ||
                strings.HasPrefix(line, "ACK ") ||
                strings.HasPrefix(line, "OPTIONS ") ||
                strings.HasPrefix(line, "REGISTER ") ||
                strings.HasPrefix(line, "CANCEL ")</span>
}

func parseSipHeaders(data []byte) (map[string]string, string) <span class="cov8" title="1">{
        // Protect against buffer overflow by limiting input size
        const maxSipMessageSize = 65536 // 64KB limit for SIP messages
        if len(data) &gt; maxSipMessageSize </span><span class="cov0" title="0">{
                logger.Debug("SIP message too large, truncating",
                        "size", len(data),
                        "max_size", maxSipMessageSize)
                data = data[:maxSipMessageSize]
        }</span>

        <span class="cov8" title="1">headers := make(map[string]string)
        text := string(data)
        lines := strings.Split(text, "\n")

        var bodyStart bool
        var bodyBuilder strings.Builder
        var isFirstLine = true
        var headerCount int
        const maxHeaders = 100 // Reasonable limit for SIP headers

        for _, line := range lines </span><span class="cov8" title="1">{
                str := strings.TrimSpace(string(line))
                if str == "" </span><span class="cov8" title="1">{
                        bodyStart = true
                        continue</span>
                }
                <span class="cov8" title="1">if !bodyStart </span><span class="cov8" title="1">{
                        // Skip the first line (SIP request/response line)
                        if isFirstLine </span><span class="cov8" title="1">{
                                isFirstLine = false
                                continue</span>
                        }

                        // Prevent header overflow attacks
                        <span class="cov8" title="1">if headerCount &gt;= maxHeaders </span><span class="cov0" title="0">{
                                logger.Debug("Too many SIP headers, ignoring remaining",
                                        "header_count", headerCount,
                                        "max_headers", maxHeaders)
                                break</span>
                        }

                        <span class="cov8" title="1">key, val := parseHeaderLine(str)
                        if key != "" </span><span class="cov8" title="1">{
                                headers[key] = val
                                headerCount++
                        }</span>
                } else<span class="cov8" title="1"> {
                        bodyBuilder.WriteString(str + "\n")
                }</span>
        }

        <span class="cov8" title="1">return headers, bodyBuilder.String()</span>
}

func parseHeaderLine(line string) (string, string) <span class="cov8" title="1">{
        parts := strings.SplitN(line, ":", 2)
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return "", ""
        }</span>
        <span class="cov8" title="1">key := strings.ToLower(strings.TrimSpace(parts[0]))
        if key == "" </span><span class="cov8" title="1">{
                return "", ""
        }</span>

        // Normalize compact form headers to full form
        <span class="cov8" title="1">key = normalizeHeaderName(key)

        return key, strings.TrimSpace(parts[1])</span>
}

// normalizeHeaderName converts SIP compact header names to their full form
func normalizeHeaderName(compact string) string <span class="cov8" title="1">{
        compactToFull := map[string]string{
                "i":  "call-id",
                "f":  "from",
                "t":  "to",
                "v":  "via",
                "c":  "contact",
                "m":  "contact", // m can also be contact in some contexts
                "l":  "content-length",
                "x":  "expires",
                "s":  "subject",
                "k":  "supported",
                "r":  "refer-to",
                "b":  "referred-by",
                "j":  "reject-contact",
                "d":  "request-disposition",
                "u":  "allow-events",
                "o":  "event",
                "a":  "accept-contact",
                "n":  "in-reply-to",
                "p":  "p-access-network-info",
        }

        if full, exists := compactToFull[compact]; exists </span><span class="cov8" title="1">{
                return full
        }</span>
        <span class="cov8" title="1">return compact</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package sipusers

import (
        "strings"
        "sync"
        "time"
)

type SipUser struct {
        ExpirationDate time.Time
}

var (
        sipUserMap = make(map[string]*SipUser)
        muSu       sync.Mutex
)

func AddSipUser(username string, newSipUser *SipUser) <span class="cov8" title="1">{
        muSu.Lock()
        defer muSu.Unlock()
        su, exists := sipUserMap[username]
        if !exists </span><span class="cov8" title="1">{
                su = &amp;SipUser{ExpirationDate: newSipUser.ExpirationDate}
                sipUserMap[username] = su
        }</span>
}

func AddMultipleSipUsers(sipUsers map[string]*SipUser) <span class="cov8" title="1">{
        for username, sipUser := range sipUsers </span><span class="cov8" title="1">{
                AddSipUser(username, sipUser)
        }</span>
}

func DeleteSipUser(username string) <span class="cov8" title="1">{
        muSu.Lock()
        defer muSu.Unlock()
        if _, ok := sipUserMap[username]; ok </span><span class="cov8" title="1">{
                delete(sipUserMap, username)
        }</span>
}

func DeleteMultipleSipUsers(usernames []string) <span class="cov8" title="1">{
        muSu.Lock()
        defer muSu.Unlock()
        for _, username := range usernames </span><span class="cov8" title="1">{
                delete(sipUserMap, username)
        }</span>
}

func IsSurveiled(sipHeader string) bool <span class="cov8" title="1">{
        muSu.Lock()
        defer muSu.Unlock()

        // Normalize SIP header to lowercase for case-insensitive matching
        normalizedHeader := strings.ToLower(sipHeader)

        for username := range sipUserMap </span><span class="cov8" title="1">{
                normalizedUsername := strings.ToLower(username)

                // Use case-insensitive matching for SIP headers
                if strings.Contains(normalizedHeader, normalizedUsername) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package voip

import (
        "bufio"
        "context"
        "io"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/endorses/lippycat/internal/pkg/capture"
        "github.com/endorses/lippycat/internal/pkg/logger"
        "github.com/google/gopacket"
        "github.com/google/gopacket/layers"
        "github.com/google/gopacket/tcpassembly"
        "github.com/google/gopacket/tcpassembly/tcpreader"
)

type CallIDDetector struct {
        mu     sync.Mutex
        callID string
        found  bool
        done   chan struct{}
        closed bool
}

func NewCallIDDetector() *CallIDDetector <span class="cov8" title="1">{
        return &amp;CallIDDetector{
                done: make(chan struct{}),
        }
}</span>

func (c *CallIDDetector) SetCallID(id string) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        if !c.found &amp;&amp; !c.closed </span><span class="cov8" title="1">{
                c.callID = id
                c.found = true
                c.closed = true
                close(c.done)
        }</span>
}

func (c *CallIDDetector) Wait() string <span class="cov8" title="1">{
        timeout := GetConfig().CallIDDetectionTimeout
        select </span>{
        case &lt;-c.done:<span class="cov8" title="1">
                c.mu.Lock()
                defer c.mu.Unlock()
                return c.callID</span>
        case &lt;-time.After(timeout):<span class="cov8" title="1"> // Prevent indefinite waiting
                return ""</span>
        }
}

func (c *CallIDDetector) Close() <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        if !c.closed </span><span class="cov8" title="1">{
                c.closed = true
                close(c.done)
        }</span>
}

type sipStreamFactory struct {
        ctx              context.Context
        cancel           context.CancelFunc
        activeGoroutines int64
        config           *Config
        lastLogTime      int64
        streamQueue      chan *queuedStream
        queueWorker      sync.WaitGroup
}

type queuedStream struct {
        reader   *tcpreader.ReaderStream
        detector *CallIDDetector
}

func NewSipStreamFactory(ctx context.Context) tcpassembly.StreamFactory <span class="cov8" title="1">{
        ctx, cancel := context.WithCancel(ctx)
        config := GetConfig()
        factory := &amp;sipStreamFactory{
                ctx:         ctx,
                cancel:      cancel,
                config:      config,
                streamQueue: make(chan *queuedStream, config.StreamQueueBuffer),
        }

        // Start queue worker goroutine to process queued streams
        factory.queueWorker.Add(1)
        go factory.processQueue()

        return factory
}</span>

func (f *sipStreamFactory) processQueue() <span class="cov8" title="1">{
        defer f.queueWorker.Done()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-f.ctx.Done():<span class="cov8" title="1">
                        // Drain the queue and close remaining streams
                        for </span><span class="cov8" title="1">{
                                select </span>{
                                case queuedStream := &lt;-f.streamQueue:<span class="cov0" title="0">
                                        if queuedStream.detector != nil </span><span class="cov0" title="0">{
                                                queuedStream.detector.Close()
                                        }</span>
                                default:<span class="cov8" title="1">
                                        return</span>
                                }
                        }
                case queuedStream := &lt;-f.streamQueue:<span class="cov0" title="0">
                        // Check if we can process this stream now
                        current := atomic.LoadInt64(&amp;f.activeGoroutines)
                        if current &lt; int64(f.config.MaxGoroutines) </span><span class="cov0" title="0">{
                                // Process the stream
                                stream := &amp;SIPStream{
                                        reader:         queuedStream.reader,
                                        callIDDetector: queuedStream.detector,
                                        ctx:            f.ctx,
                                        factory:        f,
                                }
                                atomic.AddInt64(&amp;f.activeGoroutines, 1)
                                go stream.run()
                        }</span> else<span class="cov0" title="0"> {
                                // Still at capacity, put it back in queue or drop it
                                select </span>{
                                case f.streamQueue &lt;- queuedStream:<span class="cov0" title="0"></span>
                                        // Successfully queued again
                                default:<span class="cov0" title="0">
                                        // Queue is full, gracefully close the stream
                                        logger.Warn("Stream queue full, dropping stream gracefully")
                                        if queuedStream.detector != nil </span><span class="cov0" title="0">{
                                                queuedStream.detector.Close()
                                        }</span>
                                }
                        }
                }
        }
}

func (f *sipStreamFactory) New(net, transport gopacket.Flow) tcpassembly.Stream <span class="cov8" title="1">{
        r := tcpreader.NewReaderStream()
        detector := NewCallIDDetector()

        // Check if we're at the goroutine limit
        current := atomic.LoadInt64(&amp;f.activeGoroutines)
        if current &gt;= int64(f.config.MaxGoroutines) </span><span class="cov0" title="0">{
                // Try to queue the stream instead of dropping it immediately
                queuedStream := &amp;queuedStream{
                        reader:   &amp;r,
                        detector: detector,
                }

                select </span>{
                case f.streamQueue &lt;- queuedStream:<span class="cov0" title="0">
                        // Successfully queued, stream will be processed when capacity is available
                        logger.Debug("Stream queued due to goroutine limit",
                                "max_goroutines", f.config.MaxGoroutines,
                                "current_goroutines", current,
                                "queue_length", len(f.streamQueue))</span>
                default:<span class="cov0" title="0">
                        // Queue is full, log and gracefully close
                        now := time.Now().Unix()
                        lastLog := atomic.LoadInt64(&amp;f.lastLogTime)
                        logInterval := int64(f.config.LogGoroutineLimitInterval.Seconds())
                        if now-lastLog &gt; logInterval </span><span class="cov0" title="0">{
                                atomic.StoreInt64(&amp;f.lastLogTime, now)
                                logger.Warn("SIP stream queue full, dropping stream",
                                        "max_goroutines", f.config.MaxGoroutines,
                                        "queue_capacity", cap(f.streamQueue),
                                        "action", "graceful_degradation")
                        }</span>
                        <span class="cov0" title="0">detector.Close()
                        // Return a placeholder stream that reads and discards data
                        // This prevents connection errors while gracefully degrading performance
                        go func() </span><span class="cov0" title="0">{
                                defer r.Close()
                                buf := make([]byte, 1024)
                                for </span><span class="cov0" title="0">{
                                        select </span>{
                                        case &lt;-f.ctx.Done():<span class="cov0" title="0">
                                                return</span>
                                        default:<span class="cov0" title="0">
                                                _, err := r.Read(buf)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return
                                                }</span>
                                        }
                                }
                        }()
                }
                <span class="cov0" title="0">return &amp;r</span>
        }

        // We have capacity, process immediately
        <span class="cov8" title="1">stream := &amp;SIPStream{
                reader:         &amp;r,
                callIDDetector: detector,
                ctx:            f.ctx,
                factory:        f,
        }

        // Increment goroutine counter before starting
        atomic.AddInt64(&amp;f.activeGoroutines, 1)
        go stream.run()
        return &amp;r</span>
}

func (f *sipStreamFactory) Close() <span class="cov8" title="1">{
        if f.cancel != nil </span><span class="cov8" title="1">{
                f.cancel()
        }</span>
        // Wait for the queue worker to finish
        <span class="cov8" title="1">f.queueWorker.Wait()</span>
}

// GetActiveGoroutines returns the current number of active stream processing goroutines
func (f *sipStreamFactory) GetActiveGoroutines() int64 <span class="cov8" title="1">{
        return atomic.LoadInt64(&amp;f.activeGoroutines)
}</span>

// GetMaxGoroutines returns the maximum allowed goroutines
func (f *sipStreamFactory) GetMaxGoroutines() int64 <span class="cov8" title="1">{
        return int64(f.config.MaxGoroutines)
}</span>

type SIPStream struct {
        reader         *tcpreader.ReaderStream
        callIDDetector *CallIDDetector
        ctx            context.Context
        factory        *sipStreamFactory
}

func (s *SIPStream) run() <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                // Decrement goroutine counter
                if s.factory != nil </span><span class="cov8" title="1">{
                        atomic.AddInt64(&amp;s.factory.activeGoroutines, -1)
                }</span>

                <span class="cov8" title="1">if r := recover(); r != nil </span><span class="cov8" title="1">{
                        logger.Error("SIP stream panic recovered",
                                "panic_value", r,
                                "stream_context", s.ctx.Err())
                }</span>
                // Ensure resources are cleaned up
                <span class="cov8" title="1">if s.callIDDetector != nil </span><span class="cov8" title="1">{
                        s.callIDDetector.Close()
                }</span>
        }()

        <span class="cov8" title="1">buf := bufio.NewReader(s.reader)
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-s.ctx.Done():<span class="cov8" title="1">
                        logger.Debug("SIP stream shutting down due to context cancellation")
                        return</span>
                default:<span class="cov8" title="1"></span>
                        // Continue processing
                }

                <span class="cov8" title="1">line, err := buf.ReadString('\n')
                if err != nil </span><span class="cov8" title="1">{
                        if err != io.EOF </span><span class="cov0" title="0">{
                                logger.Error("Error reading SIP stream", "error", err)
                        }</span>
                        <span class="cov8" title="1">return</span>
                }

                // Detect SIP header line with robust parsing
                <span class="cov8" title="1">var callID string
                line = strings.TrimSpace(line)

                // Handle both full and compact form headers (case-insensitive)
                if detectCallIDHeader(line, &amp;callID) </span>{<span class="cov8" title="1">
                        // Successfully parsed Call-ID
                }</span>

                <span class="cov8" title="1">if callID != "" </span><span class="cov8" title="1">{
                        s.callIDDetector.SetCallID(callID)
                        return // done after detecting first Call-ID
                }</span>
        }
}

// detectCallIDHeader robustly parses Call-ID headers in both full and compact form
func detectCallIDHeader(line string, callID *string) bool <span class="cov8" title="1">{
        line = strings.TrimSpace(line)

        // Try full form first (case-insensitive)
        if len(line) &gt; 8 &amp;&amp; strings.EqualFold(line[:8], "call-id:") </span><span class="cov8" title="1">{
                *callID = strings.TrimSpace(line[8:])
                return *callID != ""
        }</span>

        // Try compact form (case-insensitive)
        <span class="cov8" title="1">if len(line) &gt; 2 &amp;&amp; strings.EqualFold(line[:2], "i:") </span><span class="cov8" title="1">{
                *callID = strings.TrimSpace(line[2:])
                return *callID != ""
        }</span>

        <span class="cov8" title="1">return false</span>
}

func handleTcpPackets(pkt capture.PacketInfo, layer *layers.TCP, assembler *tcpassembly.Assembler) <span class="cov8" title="1">{
        if layer.SrcPort == SIPPort || layer.DstPort == SIPPort </span><span class="cov8" title="1">{
                packet := pkt.Packet
                if tcpLayer := packet.Layer(layers.LayerTypeTCP); tcpLayer != nil </span><span class="cov8" title="1">{
                        // Use the assembler properly to process the packet
                        // The stream factory will handle call ID detection
                        assembler.AssembleWithTimestamp(
                                packet.NetworkLayer().NetworkFlow(),
                                layer,
                                packet.Metadata().Timestamp,
                        )
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package voip

import (
        "sync"
        "testing"
)

// TestCallTracker creates an isolated CallTracker for testing
func TestCallTracker(t *testing.T) *CallTracker <span class="cov8" title="1">{
        tracker := NewCallTracker()
        t.Cleanup(func() </span><span class="cov8" title="1">{
                tracker.Shutdown()
        }</span>)
        <span class="cov8" title="1">return tracker</span>
}

// OverrideDefaultTracker temporarily overrides the default tracker for testing
// This should be used sparingly and only when necessary for integration tests
func OverrideDefaultTracker(tracker *CallTracker) func() <span class="cov8" title="1">{
        oldTracker := defaultTracker
        oldOnce := trackerOnce

        trackerOnce = sync.Once{}
        defaultTracker = tracker

        // Return restore function
        return func() </span><span class="cov8" title="1">{
                defaultTracker = oldTracker
                trackerOnce = oldOnce
        }</span>
}

// ResetDefaultTracker resets the default tracker singleton for testing
// Use this only in package-level test setup/teardown
func ResetDefaultTracker() <span class="cov0" title="0">{
        if defaultTracker != nil </span><span class="cov0" title="0">{
                defaultTracker.Shutdown()
        }</span>
        <span class="cov0" title="0">defaultTracker = nil
        trackerOnce = sync.Once{}</span>
}</pre>
		
		<pre class="file" id="file18" style="display: none">package voip

import (
        "fmt"
        "strings"

        "github.com/endorses/lippycat/internal/pkg/capture"
        "github.com/endorses/lippycat/internal/pkg/logger"
        "github.com/google/gopacket/layers"
        "github.com/spf13/viper"
)

func handleUdpPackets(pkt capture.PacketInfo, layer *layers.UDP) <span class="cov8" title="1">{
        packet := pkt.Packet
        if layer.SrcPort == SIPPort || layer.DstPort == SIPPort </span><span class="cov8" title="1">{
                if udpLayer := packet.Layer(layers.LayerTypeUDP); udpLayer != nil </span><span class="cov8" title="1">{
                        udp, ok := udpLayer.(*layers.UDP)
                        if !ok </span><span class="cov0" title="0">{
                                logger.Debug("Failed to assert UDP layer type")
                                return
                        }</span>
                        <span class="cov8" title="1">payload := udp.Payload
                        if !handleSipMessage(payload) </span><span class="cov8" title="1">{
                                return
                        }</span>
                        <span class="cov8" title="1">headers, body := parseSipHeaders(payload)
                        callID := headers["call-id"]
                        if callID != "" </span><span class="cov8" title="1">{
                                GetOrCreateCall(callID, pkt.LinkType)
                                if viper.GetViper().GetBool("writeVoip") </span><span class="cov0" title="0">{
                                        WriteSIP(callID, packet)
                                }</span> else<span class="cov8" title="1"> {
                                        fmt.Printf("[%s]%s\n", callID, packet)
                                }</span>
                                <span class="cov8" title="1">if strings.Contains(body, "m=audio") </span><span class="cov8" title="1">{
                                        ExtractPortFromSdp(body, callID)
                                }</span>
                        }
                }
        } else<span class="cov8" title="1"> if IsTracked(packet) </span><span class="cov8" title="1">{
                callID := GetCallIDForPacket(packet)
                if viper.GetViper().GetBool("writeVoip") </span><span class="cov0" title="0">{
                        WriteRTP(callID, packet)
                }</span> else<span class="cov8" title="1"> {
                        fmt.Printf("[%s]%s\n", callID, packet)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package voip

import (
        "os"
        "sync"
        "time"

        "github.com/endorses/lippycat/internal/pkg/logger"
        "github.com/google/gopacket"
)

var (
        sipFile, rtpFile *os.File
        writerMutex      sync.Mutex
)

func CloseWriters() <span class="cov8" title="1">{
        writerMutex.Lock()
        defer writerMutex.Unlock()

        if sipFile != nil </span><span class="cov8" title="1">{
                if err := sipFile.Close(); err != nil </span><span class="cov8" title="1">{
                        logger.Error("Error closing SIP file", "error", err)
                }</span>
                <span class="cov8" title="1">sipFile = nil</span>
        }
        <span class="cov8" title="1">if rtpFile != nil </span><span class="cov8" title="1">{
                if err := rtpFile.Close(); err != nil </span><span class="cov8" title="1">{
                        logger.Error("Error closing RTP file", "error", err)
                }</span>
                <span class="cov8" title="1">rtpFile = nil</span>
        }
}

func WriteSIP(callID string, packet gopacket.Packet) <span class="cov8" title="1">{
        tracker := getTracker()
        tracker.mu.Lock()
        defer tracker.mu.Unlock()

        if call, ok := tracker.callMap[callID]; ok &amp;&amp; call.SIPWriter != nil </span><span class="cov8" title="1">{
                if err := call.SIPWriter.WritePacket(packet.Metadata().CaptureInfo, packet.Data()); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error writing SIP packet for call",
                                "call_id", callID,
                                "error", err)
                        return
                }</span>
                <span class="cov8" title="1">call.LastUpdated = time.Now()</span>
        }
}

func WriteRTP(callID string, packet gopacket.Packet) <span class="cov8" title="1">{
        tracker := getTracker()
        tracker.mu.Lock()
        defer tracker.mu.Unlock()

        if call, ok := tracker.callMap[callID]; ok &amp;&amp; call.RTPWriter != nil </span><span class="cov8" title="1">{
                if err := call.RTPWriter.WritePacket(packet.Metadata().CaptureInfo, packet.Data()); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error writing RTP packet for call",
                                "call_id", callID,
                                "error", err)
                        return
                }</span>
                <span class="cov8" title="1">call.LastUpdated = time.Now()</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package main

import "github.com/endorses/lippycat/cmd"

func main() <span class="cov0" title="0">{
        cmd.Execute()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
