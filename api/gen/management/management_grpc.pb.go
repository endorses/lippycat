// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.32.1
// source: api/proto/management.proto

package management

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ManagementService_RegisterHunter_FullMethodName       = "/lippycat.management.ManagementService/RegisterHunter"
	ManagementService_RegisterProcessor_FullMethodName    = "/lippycat.management.ManagementService/RegisterProcessor"
	ManagementService_Heartbeat_FullMethodName            = "/lippycat.management.ManagementService/Heartbeat"
	ManagementService_GetFilters_FullMethodName           = "/lippycat.management.ManagementService/GetFilters"
	ManagementService_SubscribeFilters_FullMethodName     = "/lippycat.management.ManagementService/SubscribeFilters"
	ManagementService_GetHunterStatus_FullMethodName      = "/lippycat.management.ManagementService/GetHunterStatus"
	ManagementService_UpdateFilter_FullMethodName         = "/lippycat.management.ManagementService/UpdateFilter"
	ManagementService_DeleteFilter_FullMethodName         = "/lippycat.management.ManagementService/DeleteFilter"
	ManagementService_ListAvailableHunters_FullMethodName = "/lippycat.management.ManagementService/ListAvailableHunters"
	ManagementService_GetTopology_FullMethodName          = "/lippycat.management.ManagementService/GetTopology"
)

// ManagementServiceClient is the client API for ManagementService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ManagementService handles monitoring, configuration, and filter distribution
type ManagementServiceClient interface {
	// RegisterHunter is called when a hunter connects to a processor
	RegisterHunter(ctx context.Context, in *HunterRegistration, opts ...grpc.CallOption) (*RegistrationResponse, error)
	// RegisterProcessor is called when a processor connects to forward to upstream
	RegisterProcessor(ctx context.Context, in *ProcessorRegistration, opts ...grpc.CallOption) (*ProcessorRegistrationResponse, error)
	// Heartbeat maintains connection and reports hunter status
	Heartbeat(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[HunterHeartbeat, ProcessorHeartbeat], error)
	// GetFilters retrieves current filter configuration for a hunter
	GetFilters(ctx context.Context, in *FilterRequest, opts ...grpc.CallOption) (*FilterResponse, error)
	// SubscribeFilters is a stream for real-time filter updates
	SubscribeFilters(ctx context.Context, in *FilterRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[FilterUpdate], error)
	// GetHunterStatus retrieves status of connected hunters (for TUI)
	GetHunterStatus(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error)
	// UpdateFilter adds or modifies a filter (processor only)
	UpdateFilter(ctx context.Context, in *Filter, opts ...grpc.CallOption) (*FilterUpdateResult, error)
	// DeleteFilter removes a filter (processor only)
	DeleteFilter(ctx context.Context, in *FilterDeleteRequest, opts ...grpc.CallOption) (*FilterUpdateResult, error)
	// ListAvailableHunters retrieves list of all hunters connected to processor (for TUI hunter selection)
	ListAvailableHunters(ctx context.Context, in *ListHuntersRequest, opts ...grpc.CallOption) (*ListHuntersResponse, error)
	// GetTopology retrieves the complete downstream topology (processors and hunters)
	// Recursively queries downstream processors to build full hierarchy
	GetTopology(ctx context.Context, in *TopologyRequest, opts ...grpc.CallOption) (*TopologyResponse, error)
}

type managementServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewManagementServiceClient(cc grpc.ClientConnInterface) ManagementServiceClient {
	return &managementServiceClient{cc}
}

func (c *managementServiceClient) RegisterHunter(ctx context.Context, in *HunterRegistration, opts ...grpc.CallOption) (*RegistrationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegistrationResponse)
	err := c.cc.Invoke(ctx, ManagementService_RegisterHunter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) RegisterProcessor(ctx context.Context, in *ProcessorRegistration, opts ...grpc.CallOption) (*ProcessorRegistrationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessorRegistrationResponse)
	err := c.cc.Invoke(ctx, ManagementService_RegisterProcessor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) Heartbeat(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[HunterHeartbeat, ProcessorHeartbeat], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ManagementService_ServiceDesc.Streams[0], ManagementService_Heartbeat_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[HunterHeartbeat, ProcessorHeartbeat]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ManagementService_HeartbeatClient = grpc.BidiStreamingClient[HunterHeartbeat, ProcessorHeartbeat]

func (c *managementServiceClient) GetFilters(ctx context.Context, in *FilterRequest, opts ...grpc.CallOption) (*FilterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FilterResponse)
	err := c.cc.Invoke(ctx, ManagementService_GetFilters_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) SubscribeFilters(ctx context.Context, in *FilterRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[FilterUpdate], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ManagementService_ServiceDesc.Streams[1], ManagementService_SubscribeFilters_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[FilterRequest, FilterUpdate]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ManagementService_SubscribeFiltersClient = grpc.ServerStreamingClient[FilterUpdate]

func (c *managementServiceClient) GetHunterStatus(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, ManagementService_GetHunterStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) UpdateFilter(ctx context.Context, in *Filter, opts ...grpc.CallOption) (*FilterUpdateResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FilterUpdateResult)
	err := c.cc.Invoke(ctx, ManagementService_UpdateFilter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) DeleteFilter(ctx context.Context, in *FilterDeleteRequest, opts ...grpc.CallOption) (*FilterUpdateResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FilterUpdateResult)
	err := c.cc.Invoke(ctx, ManagementService_DeleteFilter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) ListAvailableHunters(ctx context.Context, in *ListHuntersRequest, opts ...grpc.CallOption) (*ListHuntersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListHuntersResponse)
	err := c.cc.Invoke(ctx, ManagementService_ListAvailableHunters_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) GetTopology(ctx context.Context, in *TopologyRequest, opts ...grpc.CallOption) (*TopologyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TopologyResponse)
	err := c.cc.Invoke(ctx, ManagementService_GetTopology_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ManagementServiceServer is the server API for ManagementService service.
// All implementations must embed UnimplementedManagementServiceServer
// for forward compatibility.
//
// ManagementService handles monitoring, configuration, and filter distribution
type ManagementServiceServer interface {
	// RegisterHunter is called when a hunter connects to a processor
	RegisterHunter(context.Context, *HunterRegistration) (*RegistrationResponse, error)
	// RegisterProcessor is called when a processor connects to forward to upstream
	RegisterProcessor(context.Context, *ProcessorRegistration) (*ProcessorRegistrationResponse, error)
	// Heartbeat maintains connection and reports hunter status
	Heartbeat(grpc.BidiStreamingServer[HunterHeartbeat, ProcessorHeartbeat]) error
	// GetFilters retrieves current filter configuration for a hunter
	GetFilters(context.Context, *FilterRequest) (*FilterResponse, error)
	// SubscribeFilters is a stream for real-time filter updates
	SubscribeFilters(*FilterRequest, grpc.ServerStreamingServer[FilterUpdate]) error
	// GetHunterStatus retrieves status of connected hunters (for TUI)
	GetHunterStatus(context.Context, *StatusRequest) (*StatusResponse, error)
	// UpdateFilter adds or modifies a filter (processor only)
	UpdateFilter(context.Context, *Filter) (*FilterUpdateResult, error)
	// DeleteFilter removes a filter (processor only)
	DeleteFilter(context.Context, *FilterDeleteRequest) (*FilterUpdateResult, error)
	// ListAvailableHunters retrieves list of all hunters connected to processor (for TUI hunter selection)
	ListAvailableHunters(context.Context, *ListHuntersRequest) (*ListHuntersResponse, error)
	// GetTopology retrieves the complete downstream topology (processors and hunters)
	// Recursively queries downstream processors to build full hierarchy
	GetTopology(context.Context, *TopologyRequest) (*TopologyResponse, error)
	mustEmbedUnimplementedManagementServiceServer()
}

// UnimplementedManagementServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedManagementServiceServer struct{}

func (UnimplementedManagementServiceServer) RegisterHunter(context.Context, *HunterRegistration) (*RegistrationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterHunter not implemented")
}
func (UnimplementedManagementServiceServer) RegisterProcessor(context.Context, *ProcessorRegistration) (*ProcessorRegistrationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterProcessor not implemented")
}
func (UnimplementedManagementServiceServer) Heartbeat(grpc.BidiStreamingServer[HunterHeartbeat, ProcessorHeartbeat]) error {
	return status.Errorf(codes.Unimplemented, "method Heartbeat not implemented")
}
func (UnimplementedManagementServiceServer) GetFilters(context.Context, *FilterRequest) (*FilterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFilters not implemented")
}
func (UnimplementedManagementServiceServer) SubscribeFilters(*FilterRequest, grpc.ServerStreamingServer[FilterUpdate]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeFilters not implemented")
}
func (UnimplementedManagementServiceServer) GetHunterStatus(context.Context, *StatusRequest) (*StatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHunterStatus not implemented")
}
func (UnimplementedManagementServiceServer) UpdateFilter(context.Context, *Filter) (*FilterUpdateResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateFilter not implemented")
}
func (UnimplementedManagementServiceServer) DeleteFilter(context.Context, *FilterDeleteRequest) (*FilterUpdateResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteFilter not implemented")
}
func (UnimplementedManagementServiceServer) ListAvailableHunters(context.Context, *ListHuntersRequest) (*ListHuntersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAvailableHunters not implemented")
}
func (UnimplementedManagementServiceServer) GetTopology(context.Context, *TopologyRequest) (*TopologyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTopology not implemented")
}
func (UnimplementedManagementServiceServer) mustEmbedUnimplementedManagementServiceServer() {}
func (UnimplementedManagementServiceServer) testEmbeddedByValue()                           {}

// UnsafeManagementServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ManagementServiceServer will
// result in compilation errors.
type UnsafeManagementServiceServer interface {
	mustEmbedUnimplementedManagementServiceServer()
}

func RegisterManagementServiceServer(s grpc.ServiceRegistrar, srv ManagementServiceServer) {
	// If the following call pancis, it indicates UnimplementedManagementServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ManagementService_ServiceDesc, srv)
}

func _ManagementService_RegisterHunter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HunterRegistration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).RegisterHunter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ManagementService_RegisterHunter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).RegisterHunter(ctx, req.(*HunterRegistration))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_RegisterProcessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorRegistration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).RegisterProcessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ManagementService_RegisterProcessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).RegisterProcessor(ctx, req.(*ProcessorRegistration))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_Heartbeat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ManagementServiceServer).Heartbeat(&grpc.GenericServerStream[HunterHeartbeat, ProcessorHeartbeat]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ManagementService_HeartbeatServer = grpc.BidiStreamingServer[HunterHeartbeat, ProcessorHeartbeat]

func _ManagementService_GetFilters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FilterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).GetFilters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ManagementService_GetFilters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).GetFilters(ctx, req.(*FilterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_SubscribeFilters_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FilterRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ManagementServiceServer).SubscribeFilters(m, &grpc.GenericServerStream[FilterRequest, FilterUpdate]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ManagementService_SubscribeFiltersServer = grpc.ServerStreamingServer[FilterUpdate]

func _ManagementService_GetHunterStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).GetHunterStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ManagementService_GetHunterStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).GetHunterStatus(ctx, req.(*StatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_UpdateFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Filter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).UpdateFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ManagementService_UpdateFilter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).UpdateFilter(ctx, req.(*Filter))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_DeleteFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FilterDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).DeleteFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ManagementService_DeleteFilter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).DeleteFilter(ctx, req.(*FilterDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_ListAvailableHunters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListHuntersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).ListAvailableHunters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ManagementService_ListAvailableHunters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).ListAvailableHunters(ctx, req.(*ListHuntersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_GetTopology_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TopologyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).GetTopology(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ManagementService_GetTopology_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).GetTopology(ctx, req.(*TopologyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ManagementService_ServiceDesc is the grpc.ServiceDesc for ManagementService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ManagementService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "lippycat.management.ManagementService",
	HandlerType: (*ManagementServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterHunter",
			Handler:    _ManagementService_RegisterHunter_Handler,
		},
		{
			MethodName: "RegisterProcessor",
			Handler:    _ManagementService_RegisterProcessor_Handler,
		},
		{
			MethodName: "GetFilters",
			Handler:    _ManagementService_GetFilters_Handler,
		},
		{
			MethodName: "GetHunterStatus",
			Handler:    _ManagementService_GetHunterStatus_Handler,
		},
		{
			MethodName: "UpdateFilter",
			Handler:    _ManagementService_UpdateFilter_Handler,
		},
		{
			MethodName: "DeleteFilter",
			Handler:    _ManagementService_DeleteFilter_Handler,
		},
		{
			MethodName: "ListAvailableHunters",
			Handler:    _ManagementService_ListAvailableHunters_Handler,
		},
		{
			MethodName: "GetTopology",
			Handler:    _ManagementService_GetTopology_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Heartbeat",
			Handler:       _ManagementService_Heartbeat_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SubscribeFilters",
			Handler:       _ManagementService_SubscribeFilters_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/proto/management.proto",
}
