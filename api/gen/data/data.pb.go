// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.9
// 	protoc        v6.33.1
// source: data.proto

package data

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// FlowControl signals
type FlowControl int32

const (
	// Continue sending at current rate
	FlowControl_FLOW_CONTINUE FlowControl = 0
	// Slow down transmission
	FlowControl_FLOW_SLOW FlowControl = 1
	// Pause transmission temporarily
	FlowControl_FLOW_PAUSE FlowControl = 2
	// Resume after pause
	FlowControl_FLOW_RESUME FlowControl = 3
)

// Enum value maps for FlowControl.
var (
	FlowControl_name = map[int32]string{
		0: "FLOW_CONTINUE",
		1: "FLOW_SLOW",
		2: "FLOW_PAUSE",
		3: "FLOW_RESUME",
	}
	FlowControl_value = map[string]int32{
		"FLOW_CONTINUE": 0,
		"FLOW_SLOW":     1,
		"FLOW_PAUSE":    2,
		"FLOW_RESUME":   3,
	}
)

func (x FlowControl) Enum() *FlowControl {
	p := new(FlowControl)
	*p = x
	return p
}

func (x FlowControl) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (FlowControl) Descriptor() protoreflect.EnumDescriptor {
	return file_data_proto_enumTypes[0].Descriptor()
}

func (FlowControl) Type() protoreflect.EnumType {
	return &file_data_proto_enumTypes[0]
}

func (x FlowControl) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use FlowControl.Descriptor instead.
func (FlowControl) EnumDescriptor() ([]byte, []int) {
	return file_data_proto_rawDescGZIP(), []int{0}
}

// PacketBatch contains multiple packets captured by a hunter
type PacketBatch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique hunter identifier
	HunterId string `protobuf:"bytes,1,opt,name=hunter_id,json=hunterId,proto3" json:"hunter_id,omitempty"`
	// Batch sequence number (for ordering and loss detection)
	Sequence uint64 `protobuf:"varint,2,opt,name=sequence,proto3" json:"sequence,omitempty"`
	// Timestamp when batch was created (Unix nanoseconds)
	TimestampNs int64 `protobuf:"varint,3,opt,name=timestamp_ns,json=timestampNs,proto3" json:"timestamp_ns,omitempty"`
	// Individual packets in this batch
	Packets []*CapturedPacket `protobuf:"bytes,4,rep,name=packets,proto3" json:"packets,omitempty"`
	// Statistics about this hunter's capture
	Stats         *BatchStats `protobuf:"bytes,5,opt,name=stats,proto3" json:"stats,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PacketBatch) Reset() {
	*x = PacketBatch{}
	mi := &file_data_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PacketBatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PacketBatch) ProtoMessage() {}

func (x *PacketBatch) ProtoReflect() protoreflect.Message {
	mi := &file_data_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PacketBatch.ProtoReflect.Descriptor instead.
func (*PacketBatch) Descriptor() ([]byte, []int) {
	return file_data_proto_rawDescGZIP(), []int{0}
}

func (x *PacketBatch) GetHunterId() string {
	if x != nil {
		return x.HunterId
	}
	return ""
}

func (x *PacketBatch) GetSequence() uint64 {
	if x != nil {
		return x.Sequence
	}
	return 0
}

func (x *PacketBatch) GetTimestampNs() int64 {
	if x != nil {
		return x.TimestampNs
	}
	return 0
}

func (x *PacketBatch) GetPackets() []*CapturedPacket {
	if x != nil {
		return x.Packets
	}
	return nil
}

func (x *PacketBatch) GetStats() *BatchStats {
	if x != nil {
		return x.Stats
	}
	return nil
}

// CapturedPacket represents a single captured network packet
type CapturedPacket struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Packet payload (raw network data)
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	// Capture timestamp (Unix nanoseconds)
	TimestampNs int64 `protobuf:"varint,2,opt,name=timestamp_ns,json=timestampNs,proto3" json:"timestamp_ns,omitempty"`
	// Capture length (actual bytes captured)
	CaptureLength uint32 `protobuf:"varint,3,opt,name=capture_length,json=captureLength,proto3" json:"capture_length,omitempty"`
	// Original length (may be > capture_length if truncated)
	OriginalLength uint32 `protobuf:"varint,4,opt,name=original_length,json=originalLength,proto3" json:"original_length,omitempty"`
	// Interface index where packet was captured
	InterfaceIndex uint32 `protobuf:"varint,5,opt,name=interface_index,json=interfaceIndex,proto3" json:"interface_index,omitempty"`
	// Link type (Ethernet, Raw IP, etc.) - from libpcap
	LinkType uint32 `protobuf:"varint,6,opt,name=link_type,json=linkType,proto3" json:"link_type,omitempty"`
	// Optional: Metadata from local analysis
	Metadata *PacketMetadata `protobuf:"bytes,7,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Interface name where packet was captured (e.g., "eth0", "wlan0")
	// This preserves the actual interface name across hierarchical processor chains
	InterfaceName string `protobuf:"bytes,8,opt,name=interface_name,json=interfaceName,proto3" json:"interface_name,omitempty"`
	// Matched filter IDs (for LI correlation)
	// Populated by hunters/LocalSource when a packet matches application filters.
	// Used by the processor to correlate packets to LI intercept tasks.
	MatchedFilterIds []string `protobuf:"bytes,9,rep,name=matched_filter_ids,json=matchedFilterIds,proto3" json:"matched_filter_ids,omitempty"`
	// TLS session keys for decryption (forwarded on first matched packet of session)
	// Original encrypted packets are preserved for audit integrity.
	// Processor uses these keys to decrypt traffic for display/analysis.
	TlsKeys       *TLSSessionKeys `protobuf:"bytes,10,opt,name=tls_keys,json=tlsKeys,proto3" json:"tls_keys,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CapturedPacket) Reset() {
	*x = CapturedPacket{}
	mi := &file_data_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CapturedPacket) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CapturedPacket) ProtoMessage() {}

func (x *CapturedPacket) ProtoReflect() protoreflect.Message {
	mi := &file_data_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CapturedPacket.ProtoReflect.Descriptor instead.
func (*CapturedPacket) Descriptor() ([]byte, []int) {
	return file_data_proto_rawDescGZIP(), []int{1}
}

func (x *CapturedPacket) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *CapturedPacket) GetTimestampNs() int64 {
	if x != nil {
		return x.TimestampNs
	}
	return 0
}

func (x *CapturedPacket) GetCaptureLength() uint32 {
	if x != nil {
		return x.CaptureLength
	}
	return 0
}

func (x *CapturedPacket) GetOriginalLength() uint32 {
	if x != nil {
		return x.OriginalLength
	}
	return 0
}

func (x *CapturedPacket) GetInterfaceIndex() uint32 {
	if x != nil {
		return x.InterfaceIndex
	}
	return 0
}

func (x *CapturedPacket) GetLinkType() uint32 {
	if x != nil {
		return x.LinkType
	}
	return 0
}

func (x *CapturedPacket) GetMetadata() *PacketMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *CapturedPacket) GetInterfaceName() string {
	if x != nil {
		return x.InterfaceName
	}
	return ""
}

func (x *CapturedPacket) GetMatchedFilterIds() []string {
	if x != nil {
		return x.MatchedFilterIds
	}
	return nil
}

func (x *CapturedPacket) GetTlsKeys() *TLSSessionKeys {
	if x != nil {
		return x.TlsKeys
	}
	return nil
}

// PacketMetadata contains hunter-side analysis results
type PacketMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Protocol detected (e.g., "SIP", "RTP", "RTCP")
	Protocol string `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// Source IP address
	SrcIp string `protobuf:"bytes,2,opt,name=src_ip,json=srcIp,proto3" json:"src_ip,omitempty"`
	// Destination IP address
	DstIp string `protobuf:"bytes,3,opt,name=dst_ip,json=dstIp,proto3" json:"dst_ip,omitempty"`
	// Source port
	SrcPort uint32 `protobuf:"varint,4,opt,name=src_port,json=srcPort,proto3" json:"src_port,omitempty"`
	// Destination port
	DstPort uint32 `protobuf:"varint,5,opt,name=dst_port,json=dstPort,proto3" json:"dst_port,omitempty"`
	// Transport protocol (TCP, UDP, etc.)
	Transport string `protobuf:"bytes,6,opt,name=transport,proto3" json:"transport,omitempty"`
	// SIP-specific metadata (if applicable)
	Sip *SIPMetadata `protobuf:"bytes,7,opt,name=sip,proto3" json:"sip,omitempty"`
	// RTP-specific metadata (if applicable)
	Rtp *RTPMetadata `protobuf:"bytes,8,opt,name=rtp,proto3" json:"rtp,omitempty"`
	// Generic info string for display (e.g., "SSH-2.0-OpenSSH_...", "Echo Reply")
	Info string `protobuf:"bytes,9,opt,name=info,proto3" json:"info,omitempty"`
	// Generic key-value details for protocol-specific data
	Details map[string]string `protobuf:"bytes,10,rep,name=details,proto3" json:"details,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Email-specific metadata (if applicable)
	Email *EmailMetadata `protobuf:"bytes,11,opt,name=email,proto3" json:"email,omitempty"`
	// DNS-specific metadata (if applicable)
	Dns           *DNSMetadata `protobuf:"bytes,12,opt,name=dns,proto3" json:"dns,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PacketMetadata) Reset() {
	*x = PacketMetadata{}
	mi := &file_data_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PacketMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PacketMetadata) ProtoMessage() {}

func (x *PacketMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_data_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PacketMetadata.ProtoReflect.Descriptor instead.
func (*PacketMetadata) Descriptor() ([]byte, []int) {
	return file_data_proto_rawDescGZIP(), []int{2}
}

func (x *PacketMetadata) GetProtocol() string {
	if x != nil {
		return x.Protocol
	}
	return ""
}

func (x *PacketMetadata) GetSrcIp() string {
	if x != nil {
		return x.SrcIp
	}
	return ""
}

func (x *PacketMetadata) GetDstIp() string {
	if x != nil {
		return x.DstIp
	}
	return ""
}

func (x *PacketMetadata) GetSrcPort() uint32 {
	if x != nil {
		return x.SrcPort
	}
	return 0
}

func (x *PacketMetadata) GetDstPort() uint32 {
	if x != nil {
		return x.DstPort
	}
	return 0
}

func (x *PacketMetadata) GetTransport() string {
	if x != nil {
		return x.Transport
	}
	return ""
}

func (x *PacketMetadata) GetSip() *SIPMetadata {
	if x != nil {
		return x.Sip
	}
	return nil
}

func (x *PacketMetadata) GetRtp() *RTPMetadata {
	if x != nil {
		return x.Rtp
	}
	return nil
}

func (x *PacketMetadata) GetInfo() string {
	if x != nil {
		return x.Info
	}
	return ""
}

func (x *PacketMetadata) GetDetails() map[string]string {
	if x != nil {
		return x.Details
	}
	return nil
}

func (x *PacketMetadata) GetEmail() *EmailMetadata {
	if x != nil {
		return x.Email
	}
	return nil
}

func (x *PacketMetadata) GetDns() *DNSMetadata {
	if x != nil {
		return x.Dns
	}
	return nil
}

// SIPMetadata for SIP packets
type SIPMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// SIP method (INVITE, BYE, REGISTER, etc.)
	Method string `protobuf:"bytes,1,opt,name=method,proto3" json:"method,omitempty"`
	// Call-ID
	CallId string `protobuf:"bytes,2,opt,name=call_id,json=callId,proto3" json:"call_id,omitempty"`
	// From user
	FromUser string `protobuf:"bytes,3,opt,name=from_user,json=fromUser,proto3" json:"from_user,omitempty"`
	// To user
	ToUser string `protobuf:"bytes,4,opt,name=to_user,json=toUser,proto3" json:"to_user,omitempty"`
	// Response code (for responses)
	ResponseCode uint32 `protobuf:"varint,5,opt,name=response_code,json=responseCode,proto3" json:"response_code,omitempty"`
	// P-Asserted-Identity header (RFC 3325)
	PAssertedIdentity string `protobuf:"bytes,6,opt,name=p_asserted_identity,json=pAssertedIdentity,proto3" json:"p_asserted_identity,omitempty"`
	// From tag parameter (for dialog correlation)
	FromTag string `protobuf:"bytes,7,opt,name=from_tag,json=fromTag,proto3" json:"from_tag,omitempty"`
	// To tag parameter (for dialog correlation)
	ToTag string `protobuf:"bytes,8,opt,name=to_tag,json=toTag,proto3" json:"to_tag,omitempty"`
	// Full From URI (for display)
	FromUri string `protobuf:"bytes,9,opt,name=from_uri,json=fromUri,proto3" json:"from_uri,omitempty"`
	// Full To URI (for display)
	ToUri         string `protobuf:"bytes,10,opt,name=to_uri,json=toUri,proto3" json:"to_uri,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SIPMetadata) Reset() {
	*x = SIPMetadata{}
	mi := &file_data_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SIPMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SIPMetadata) ProtoMessage() {}

func (x *SIPMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_data_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SIPMetadata.ProtoReflect.Descriptor instead.
func (*SIPMetadata) Descriptor() ([]byte, []int) {
	return file_data_proto_rawDescGZIP(), []int{3}
}

func (x *SIPMetadata) GetMethod() string {
	if x != nil {
		return x.Method
	}
	return ""
}

func (x *SIPMetadata) GetCallId() string {
	if x != nil {
		return x.CallId
	}
	return ""
}

func (x *SIPMetadata) GetFromUser() string {
	if x != nil {
		return x.FromUser
	}
	return ""
}

func (x *SIPMetadata) GetToUser() string {
	if x != nil {
		return x.ToUser
	}
	return ""
}

func (x *SIPMetadata) GetResponseCode() uint32 {
	if x != nil {
		return x.ResponseCode
	}
	return 0
}

func (x *SIPMetadata) GetPAssertedIdentity() string {
	if x != nil {
		return x.PAssertedIdentity
	}
	return ""
}

func (x *SIPMetadata) GetFromTag() string {
	if x != nil {
		return x.FromTag
	}
	return ""
}

func (x *SIPMetadata) GetToTag() string {
	if x != nil {
		return x.ToTag
	}
	return ""
}

func (x *SIPMetadata) GetFromUri() string {
	if x != nil {
		return x.FromUri
	}
	return ""
}

func (x *SIPMetadata) GetToUri() string {
	if x != nil {
		return x.ToUri
	}
	return ""
}

// RTPMetadata for RTP packets
type RTPMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// SSRC identifier
	Ssrc uint32 `protobuf:"varint,1,opt,name=ssrc,proto3" json:"ssrc,omitempty"`
	// Payload type
	PayloadType uint32 `protobuf:"varint,2,opt,name=payload_type,json=payloadType,proto3" json:"payload_type,omitempty"`
	// Sequence number
	Sequence uint32 `protobuf:"varint,3,opt,name=sequence,proto3" json:"sequence,omitempty"`
	// Timestamp
	Timestamp     uint32 `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RTPMetadata) Reset() {
	*x = RTPMetadata{}
	mi := &file_data_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RTPMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RTPMetadata) ProtoMessage() {}

func (x *RTPMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_data_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RTPMetadata.ProtoReflect.Descriptor instead.
func (*RTPMetadata) Descriptor() ([]byte, []int) {
	return file_data_proto_rawDescGZIP(), []int{4}
}

func (x *RTPMetadata) GetSsrc() uint32 {
	if x != nil {
		return x.Ssrc
	}
	return 0
}

func (x *RTPMetadata) GetPayloadType() uint32 {
	if x != nil {
		return x.PayloadType
	}
	return 0
}

func (x *RTPMetadata) GetSequence() uint32 {
	if x != nil {
		return x.Sequence
	}
	return 0
}

func (x *RTPMetadata) GetTimestamp() uint32 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

// DNSMetadata for DNS packets
type DNSMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Header fields
	TransactionId uint32 `protobuf:"varint,1,opt,name=transaction_id,json=transactionId,proto3" json:"transaction_id,omitempty"` // DNS transaction ID for query/response correlation
	IsResponse    bool   `protobuf:"varint,2,opt,name=is_response,json=isResponse,proto3" json:"is_response,omitempty"`          // True if response, false if query
	Opcode        string `protobuf:"bytes,3,opt,name=opcode,proto3" json:"opcode,omitempty"`                                     // Operation type (QUERY, IQUERY, STATUS, NOTIFY, UPDATE, DSO)
	ResponseCode  string `protobuf:"bytes,4,opt,name=response_code,json=responseCode,proto3" json:"response_code,omitempty"`     // Response code (NOERROR, NXDOMAIN, SERVFAIL, etc.)
	// Header flags
	Authoritative      bool `protobuf:"varint,5,opt,name=authoritative,proto3" json:"authoritative,omitempty"`                                     // AA: Authoritative Answer
	Truncated          bool `protobuf:"varint,6,opt,name=truncated,proto3" json:"truncated,omitempty"`                                             // TC: Message truncated
	RecursionDesired   bool `protobuf:"varint,7,opt,name=recursion_desired,json=recursionDesired,proto3" json:"recursion_desired,omitempty"`       // RD: Recursion Desired
	RecursionAvailable bool `protobuf:"varint,8,opt,name=recursion_available,json=recursionAvailable,proto3" json:"recursion_available,omitempty"` // RA: Recursion Available
	AuthenticatedData  bool `protobuf:"varint,9,opt,name=authenticated_data,json=authenticatedData,proto3" json:"authenticated_data,omitempty"`    // AD: Authenticated Data (DNSSEC)
	CheckingDisabled   bool `protobuf:"varint,10,opt,name=checking_disabled,json=checkingDisabled,proto3" json:"checking_disabled,omitempty"`      // CD: Checking Disabled (DNSSEC)
	// Record counts
	QuestionCount   uint32 `protobuf:"varint,11,opt,name=question_count,json=questionCount,proto3" json:"question_count,omitempty"`       // Number of questions
	AnswerCount     uint32 `protobuf:"varint,12,opt,name=answer_count,json=answerCount,proto3" json:"answer_count,omitempty"`             // Number of answer records
	AuthorityCount  uint32 `protobuf:"varint,13,opt,name=authority_count,json=authorityCount,proto3" json:"authority_count,omitempty"`    // Number of authority records
	AdditionalCount uint32 `protobuf:"varint,14,opt,name=additional_count,json=additionalCount,proto3" json:"additional_count,omitempty"` // Number of additional records
	// Query information (parsed from question section)
	QueryName  string `protobuf:"bytes,15,opt,name=query_name,json=queryName,proto3" json:"query_name,omitempty"`    // Queried domain name (e.g., "example.com")
	QueryType  string `protobuf:"bytes,16,opt,name=query_type,json=queryType,proto3" json:"query_type,omitempty"`    // Record type (A, AAAA, MX, CNAME, TXT, etc.)
	QueryClass string `protobuf:"bytes,17,opt,name=query_class,json=queryClass,proto3" json:"query_class,omitempty"` // Query class (usually IN for Internet)
	// Response information (parsed from answer section)
	Answers []*DNSAnswer `protobuf:"bytes,18,rep,name=answers,proto3" json:"answers,omitempty"` // Parsed answer records
	// Correlation and timing
	QueryResponseTimeMs int64 `protobuf:"varint,19,opt,name=query_response_time_ms,json=queryResponseTimeMs,proto3" json:"query_response_time_ms,omitempty"` // Response latency (only for correlated responses)
	CorrelatedQuery     bool  `protobuf:"varint,20,opt,name=correlated_query,json=correlatedQuery,proto3" json:"correlated_query,omitempty"`                 // True if response was correlated with a query
	// Security analysis (tunneling detection)
	TunnelingScore float64 `protobuf:"fixed64,21,opt,name=tunneling_score,json=tunnelingScore,proto3" json:"tunneling_score,omitempty"` // DNS tunneling probability (0.0-1.0)
	EntropyScore   float64 `protobuf:"fixed64,22,opt,name=entropy_score,json=entropyScore,proto3" json:"entropy_score,omitempty"`       // Entropy of query name (for tunneling detection)
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *DNSMetadata) Reset() {
	*x = DNSMetadata{}
	mi := &file_data_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DNSMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DNSMetadata) ProtoMessage() {}

func (x *DNSMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_data_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DNSMetadata.ProtoReflect.Descriptor instead.
func (*DNSMetadata) Descriptor() ([]byte, []int) {
	return file_data_proto_rawDescGZIP(), []int{5}
}

func (x *DNSMetadata) GetTransactionId() uint32 {
	if x != nil {
		return x.TransactionId
	}
	return 0
}

func (x *DNSMetadata) GetIsResponse() bool {
	if x != nil {
		return x.IsResponse
	}
	return false
}

func (x *DNSMetadata) GetOpcode() string {
	if x != nil {
		return x.Opcode
	}
	return ""
}

func (x *DNSMetadata) GetResponseCode() string {
	if x != nil {
		return x.ResponseCode
	}
	return ""
}

func (x *DNSMetadata) GetAuthoritative() bool {
	if x != nil {
		return x.Authoritative
	}
	return false
}

func (x *DNSMetadata) GetTruncated() bool {
	if x != nil {
		return x.Truncated
	}
	return false
}

func (x *DNSMetadata) GetRecursionDesired() bool {
	if x != nil {
		return x.RecursionDesired
	}
	return false
}

func (x *DNSMetadata) GetRecursionAvailable() bool {
	if x != nil {
		return x.RecursionAvailable
	}
	return false
}

func (x *DNSMetadata) GetAuthenticatedData() bool {
	if x != nil {
		return x.AuthenticatedData
	}
	return false
}

func (x *DNSMetadata) GetCheckingDisabled() bool {
	if x != nil {
		return x.CheckingDisabled
	}
	return false
}

func (x *DNSMetadata) GetQuestionCount() uint32 {
	if x != nil {
		return x.QuestionCount
	}
	return 0
}

func (x *DNSMetadata) GetAnswerCount() uint32 {
	if x != nil {
		return x.AnswerCount
	}
	return 0
}

func (x *DNSMetadata) GetAuthorityCount() uint32 {
	if x != nil {
		return x.AuthorityCount
	}
	return 0
}

func (x *DNSMetadata) GetAdditionalCount() uint32 {
	if x != nil {
		return x.AdditionalCount
	}
	return 0
}

func (x *DNSMetadata) GetQueryName() string {
	if x != nil {
		return x.QueryName
	}
	return ""
}

func (x *DNSMetadata) GetQueryType() string {
	if x != nil {
		return x.QueryType
	}
	return ""
}

func (x *DNSMetadata) GetQueryClass() string {
	if x != nil {
		return x.QueryClass
	}
	return ""
}

func (x *DNSMetadata) GetAnswers() []*DNSAnswer {
	if x != nil {
		return x.Answers
	}
	return nil
}

func (x *DNSMetadata) GetQueryResponseTimeMs() int64 {
	if x != nil {
		return x.QueryResponseTimeMs
	}
	return 0
}

func (x *DNSMetadata) GetCorrelatedQuery() bool {
	if x != nil {
		return x.CorrelatedQuery
	}
	return false
}

func (x *DNSMetadata) GetTunnelingScore() float64 {
	if x != nil {
		return x.TunnelingScore
	}
	return 0
}

func (x *DNSMetadata) GetEntropyScore() float64 {
	if x != nil {
		return x.EntropyScore
	}
	return 0
}

// DNSAnswer represents a single DNS answer record
type DNSAnswer struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`   // Domain name
	Type          string                 `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`   // Record type (A, AAAA, CNAME, etc.)
	Class         string                 `protobuf:"bytes,3,opt,name=class,proto3" json:"class,omitempty"` // Record class (usually IN)
	Ttl           uint32                 `protobuf:"varint,4,opt,name=ttl,proto3" json:"ttl,omitempty"`    // Time to live in seconds
	Data          string                 `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty"`   // Answer data (IP address, CNAME target, etc.)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DNSAnswer) Reset() {
	*x = DNSAnswer{}
	mi := &file_data_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DNSAnswer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DNSAnswer) ProtoMessage() {}

func (x *DNSAnswer) ProtoReflect() protoreflect.Message {
	mi := &file_data_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DNSAnswer.ProtoReflect.Descriptor instead.
func (*DNSAnswer) Descriptor() ([]byte, []int) {
	return file_data_proto_rawDescGZIP(), []int{6}
}

func (x *DNSAnswer) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *DNSAnswer) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *DNSAnswer) GetClass() string {
	if x != nil {
		return x.Class
	}
	return ""
}

func (x *DNSAnswer) GetTtl() uint32 {
	if x != nil {
		return x.Ttl
	}
	return 0
}

func (x *DNSAnswer) GetData() string {
	if x != nil {
		return x.Data
	}
	return ""
}

// EmailMetadata for SMTP/email packets
type EmailMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// MAIL FROM address
	MailFrom string `protobuf:"bytes,1,opt,name=mail_from,json=mailFrom,proto3" json:"mail_from,omitempty"`
	// RCPT TO addresses
	RcptTo []string `protobuf:"bytes,2,rep,name=rcpt_to,json=rcptTo,proto3" json:"rcpt_to,omitempty"`
	// Subject header
	Subject string `protobuf:"bytes,3,opt,name=subject,proto3" json:"subject,omitempty"`
	// Message-ID header
	MessageId string `protobuf:"bytes,4,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	// Body preview (limited to configured max size)
	BodyPreview string `protobuf:"bytes,5,opt,name=body_preview,json=bodyPreview,proto3" json:"body_preview,omitempty"`
	// Full body size in bytes
	BodySize int32 `protobuf:"varint,6,opt,name=body_size,json=bodySize,proto3" json:"body_size,omitempty"`
	// True if body was truncated due to size limit
	BodyTruncated bool `protobuf:"varint,7,opt,name=body_truncated,json=bodyTruncated,proto3" json:"body_truncated,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EmailMetadata) Reset() {
	*x = EmailMetadata{}
	mi := &file_data_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EmailMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EmailMetadata) ProtoMessage() {}

func (x *EmailMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_data_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EmailMetadata.ProtoReflect.Descriptor instead.
func (*EmailMetadata) Descriptor() ([]byte, []int) {
	return file_data_proto_rawDescGZIP(), []int{7}
}

func (x *EmailMetadata) GetMailFrom() string {
	if x != nil {
		return x.MailFrom
	}
	return ""
}

func (x *EmailMetadata) GetRcptTo() []string {
	if x != nil {
		return x.RcptTo
	}
	return nil
}

func (x *EmailMetadata) GetSubject() string {
	if x != nil {
		return x.Subject
	}
	return ""
}

func (x *EmailMetadata) GetMessageId() string {
	if x != nil {
		return x.MessageId
	}
	return ""
}

func (x *EmailMetadata) GetBodyPreview() string {
	if x != nil {
		return x.BodyPreview
	}
	return ""
}

func (x *EmailMetadata) GetBodySize() int32 {
	if x != nil {
		return x.BodySize
	}
	return 0
}

func (x *EmailMetadata) GetBodyTruncated() bool {
	if x != nil {
		return x.BodyTruncated
	}
	return false
}

// BatchStats contains statistics about a hunter's capture
type BatchStats struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Total packets captured (before filtering)
	TotalCaptured uint64 `protobuf:"varint,1,opt,name=total_captured,json=totalCaptured,proto3" json:"total_captured,omitempty"`
	// Packets that matched filters
	FilteredMatched uint64 `protobuf:"varint,2,opt,name=filtered_matched,json=filteredMatched,proto3" json:"filtered_matched,omitempty"`
	// Packets dropped (buffer full, etc.)
	Dropped uint64 `protobuf:"varint,3,opt,name=dropped,proto3" json:"dropped,omitempty"`
	// Current buffer usage percentage (0-100)
	BufferUsage   uint32 `protobuf:"varint,4,opt,name=buffer_usage,json=bufferUsage,proto3" json:"buffer_usage,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BatchStats) Reset() {
	*x = BatchStats{}
	mi := &file_data_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatchStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchStats) ProtoMessage() {}

func (x *BatchStats) ProtoReflect() protoreflect.Message {
	mi := &file_data_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchStats.ProtoReflect.Descriptor instead.
func (*BatchStats) Descriptor() ([]byte, []int) {
	return file_data_proto_rawDescGZIP(), []int{8}
}

func (x *BatchStats) GetTotalCaptured() uint64 {
	if x != nil {
		return x.TotalCaptured
	}
	return 0
}

func (x *BatchStats) GetFilteredMatched() uint64 {
	if x != nil {
		return x.FilteredMatched
	}
	return 0
}

func (x *BatchStats) GetDropped() uint64 {
	if x != nil {
		return x.Dropped
	}
	return 0
}

func (x *BatchStats) GetBufferUsage() uint32 {
	if x != nil {
		return x.BufferUsage
	}
	return 0
}

// StreamControl messages from processor to hunter
type StreamControl struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Acknowledged sequence number
	AckSequence uint64 `protobuf:"varint,1,opt,name=ack_sequence,json=ackSequence,proto3" json:"ack_sequence,omitempty"`
	// Flow control signal
	FlowControl FlowControl `protobuf:"varint,2,opt,name=flow_control,json=flowControl,proto3,enum=lippycat.data.FlowControl" json:"flow_control,omitempty"`
	// Error message (if any)
	Error         string `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamControl) Reset() {
	*x = StreamControl{}
	mi := &file_data_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamControl) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamControl) ProtoMessage() {}

func (x *StreamControl) ProtoReflect() protoreflect.Message {
	mi := &file_data_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamControl.ProtoReflect.Descriptor instead.
func (*StreamControl) Descriptor() ([]byte, []int) {
	return file_data_proto_rawDescGZIP(), []int{9}
}

func (x *StreamControl) GetAckSequence() uint64 {
	if x != nil {
		return x.AckSequence
	}
	return 0
}

func (x *StreamControl) GetFlowControl() FlowControl {
	if x != nil {
		return x.FlowControl
	}
	return FlowControl_FLOW_CONTINUE
}

func (x *StreamControl) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// SubscribeRequest for monitoring clients to subscribe to packet stream
type SubscribeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional: Filter by specific hunter IDs
	// If has_hunter_filter = false: subscribe to all hunters (default)
	// If has_hunter_filter = true and hunter_ids is empty: subscribe to no hunters
	// If has_hunter_filter = true and hunter_ids is non-empty: subscribe to specific hunters
	HunterIds []string `protobuf:"bytes,1,rep,name=hunter_ids,json=hunterIds,proto3" json:"hunter_ids,omitempty"`
	// Optional: BPF filter to apply on server side
	BpfFilter string `protobuf:"bytes,2,opt,name=bpf_filter,json=bpfFilter,proto3" json:"bpf_filter,omitempty"`
	// Client identifier for logging/tracking
	ClientId string `protobuf:"bytes,3,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	// Explicitly indicates whether hunter_ids filter is set
	// This distinguishes between "not set" (subscribe to all) and "empty list" (subscribe to none)
	HasHunterFilter bool `protobuf:"varint,4,opt,name=has_hunter_filter,json=hasHunterFilter,proto3" json:"has_hunter_filter,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *SubscribeRequest) Reset() {
	*x = SubscribeRequest{}
	mi := &file_data_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubscribeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubscribeRequest) ProtoMessage() {}

func (x *SubscribeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_data_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubscribeRequest.ProtoReflect.Descriptor instead.
func (*SubscribeRequest) Descriptor() ([]byte, []int) {
	return file_data_proto_rawDescGZIP(), []int{10}
}

func (x *SubscribeRequest) GetHunterIds() []string {
	if x != nil {
		return x.HunterIds
	}
	return nil
}

func (x *SubscribeRequest) GetBpfFilter() string {
	if x != nil {
		return x.BpfFilter
	}
	return ""
}

func (x *SubscribeRequest) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

func (x *SubscribeRequest) GetHasHunterFilter() bool {
	if x != nil {
		return x.HasHunterFilter
	}
	return false
}

// CorrelatedCallUpdate contains information about a call correlated across B2BUA boundaries
type CorrelatedCallUpdate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Correlation ID (hash of normalized tag pair)
	CorrelationId string `protobuf:"bytes,1,opt,name=correlation_id,json=correlationId,proto3" json:"correlation_id,omitempty"`
	// Normalized tag pair [tag1, tag2] (sorted alphabetically)
	TagPair []string `protobuf:"bytes,2,rep,name=tag_pair,json=tagPair,proto3" json:"tag_pair,omitempty"`
	// From user (participant A)
	FromUser string `protobuf:"bytes,3,opt,name=from_user,json=fromUser,proto3" json:"from_user,omitempty"`
	// To user (participant B)
	ToUser string `protobuf:"bytes,4,opt,name=to_user,json=toUser,proto3" json:"to_user,omitempty"`
	// Call legs (one per B2BUA hop)
	Legs []*CallLegInfo `protobuf:"bytes,5,rep,name=legs,proto3" json:"legs,omitempty"`
	// Start time (Unix nanoseconds)
	StartTimeNs int64 `protobuf:"varint,6,opt,name=start_time_ns,json=startTimeNs,proto3" json:"start_time_ns,omitempty"`
	// Last seen time (Unix nanoseconds)
	LastSeenNs int64 `protobuf:"varint,7,opt,name=last_seen_ns,json=lastSeenNs,proto3" json:"last_seen_ns,omitempty"`
	// Call state
	State         string `protobuf:"bytes,8,opt,name=state,proto3" json:"state,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CorrelatedCallUpdate) Reset() {
	*x = CorrelatedCallUpdate{}
	mi := &file_data_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CorrelatedCallUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CorrelatedCallUpdate) ProtoMessage() {}

func (x *CorrelatedCallUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_data_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CorrelatedCallUpdate.ProtoReflect.Descriptor instead.
func (*CorrelatedCallUpdate) Descriptor() ([]byte, []int) {
	return file_data_proto_rawDescGZIP(), []int{11}
}

func (x *CorrelatedCallUpdate) GetCorrelationId() string {
	if x != nil {
		return x.CorrelationId
	}
	return ""
}

func (x *CorrelatedCallUpdate) GetTagPair() []string {
	if x != nil {
		return x.TagPair
	}
	return nil
}

func (x *CorrelatedCallUpdate) GetFromUser() string {
	if x != nil {
		return x.FromUser
	}
	return ""
}

func (x *CorrelatedCallUpdate) GetToUser() string {
	if x != nil {
		return x.ToUser
	}
	return ""
}

func (x *CorrelatedCallUpdate) GetLegs() []*CallLegInfo {
	if x != nil {
		return x.Legs
	}
	return nil
}

func (x *CorrelatedCallUpdate) GetStartTimeNs() int64 {
	if x != nil {
		return x.StartTimeNs
	}
	return 0
}

func (x *CorrelatedCallUpdate) GetLastSeenNs() int64 {
	if x != nil {
		return x.LastSeenNs
	}
	return 0
}

func (x *CorrelatedCallUpdate) GetState() string {
	if x != nil {
		return x.State
	}
	return ""
}

// CallLegInfo represents one leg of a multi-hop call
type CallLegInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Call-ID for this leg
	CallId string `protobuf:"bytes,1,opt,name=call_id,json=callId,proto3" json:"call_id,omitempty"`
	// Hunter ID where this leg was observed
	HunterId string `protobuf:"bytes,2,opt,name=hunter_id,json=hunterId,proto3" json:"hunter_id,omitempty"`
	// Source IP address
	SrcIp string `protobuf:"bytes,3,opt,name=src_ip,json=srcIp,proto3" json:"src_ip,omitempty"`
	// Destination IP address
	DstIp string `protobuf:"bytes,4,opt,name=dst_ip,json=dstIp,proto3" json:"dst_ip,omitempty"`
	// Last SIP method seen
	Method string `protobuf:"bytes,5,opt,name=method,proto3" json:"method,omitempty"`
	// Last response code seen
	ResponseCode uint32 `protobuf:"varint,6,opt,name=response_code,json=responseCode,proto3" json:"response_code,omitempty"`
	// Packet count for this leg
	PacketCount int32 `protobuf:"varint,7,opt,name=packet_count,json=packetCount,proto3" json:"packet_count,omitempty"`
	// Start time for this leg (Unix nanoseconds)
	StartTimeNs int64 `protobuf:"varint,8,opt,name=start_time_ns,json=startTimeNs,proto3" json:"start_time_ns,omitempty"`
	// Last seen time for this leg (Unix nanoseconds)
	LastSeenNs    int64 `protobuf:"varint,9,opt,name=last_seen_ns,json=lastSeenNs,proto3" json:"last_seen_ns,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CallLegInfo) Reset() {
	*x = CallLegInfo{}
	mi := &file_data_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CallLegInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CallLegInfo) ProtoMessage() {}

func (x *CallLegInfo) ProtoReflect() protoreflect.Message {
	mi := &file_data_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CallLegInfo.ProtoReflect.Descriptor instead.
func (*CallLegInfo) Descriptor() ([]byte, []int) {
	return file_data_proto_rawDescGZIP(), []int{12}
}

func (x *CallLegInfo) GetCallId() string {
	if x != nil {
		return x.CallId
	}
	return ""
}

func (x *CallLegInfo) GetHunterId() string {
	if x != nil {
		return x.HunterId
	}
	return ""
}

func (x *CallLegInfo) GetSrcIp() string {
	if x != nil {
		return x.SrcIp
	}
	return ""
}

func (x *CallLegInfo) GetDstIp() string {
	if x != nil {
		return x.DstIp
	}
	return ""
}

func (x *CallLegInfo) GetMethod() string {
	if x != nil {
		return x.Method
	}
	return ""
}

func (x *CallLegInfo) GetResponseCode() uint32 {
	if x != nil {
		return x.ResponseCode
	}
	return 0
}

func (x *CallLegInfo) GetPacketCount() int32 {
	if x != nil {
		return x.PacketCount
	}
	return 0
}

func (x *CallLegInfo) GetStartTimeNs() int64 {
	if x != nil {
		return x.StartTimeNs
	}
	return 0
}

func (x *CallLegInfo) GetLastSeenNs() int64 {
	if x != nil {
		return x.LastSeenNs
	}
	return 0
}

// TLSSessionKeys contains session keys for TLS decryption
// Keys are forwarded from hunters to processors when a TLS session matches filters.
// This enables processors to decrypt traffic for display while storing original
// encrypted packets for audit integrity.
type TLSSessionKeys struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Client random (32 bytes) - unique session identifier from ClientHello
	ClientRandom []byte `protobuf:"bytes,1,opt,name=client_random,json=clientRandom,proto3" json:"client_random,omitempty"`
	// Server random (32 bytes) - from ServerHello, for correlation
	ServerRandom []byte `protobuf:"bytes,2,opt,name=server_random,json=serverRandom,proto3" json:"server_random,omitempty"`
	// TLS version (e.g., 0x0303 for TLS 1.2, 0x0304 for TLS 1.3)
	TlsVersion uint32 `protobuf:"varint,3,opt,name=tls_version,json=tlsVersion,proto3" json:"tls_version,omitempty"`
	// Cipher suite (e.g., 0x1301 for TLS_AES_128_GCM_SHA256)
	CipherSuite uint32 `protobuf:"varint,4,opt,name=cipher_suite,json=cipherSuite,proto3" json:"cipher_suite,omitempty"`
	// TLS 1.2: Pre-master secret (48 bytes)
	PreMasterSecret []byte `protobuf:"bytes,5,opt,name=pre_master_secret,json=preMasterSecret,proto3" json:"pre_master_secret,omitempty"`
	// TLS 1.3: Handshake traffic secrets
	ClientHandshakeTrafficSecret []byte `protobuf:"bytes,6,opt,name=client_handshake_traffic_secret,json=clientHandshakeTrafficSecret,proto3" json:"client_handshake_traffic_secret,omitempty"`
	ServerHandshakeTrafficSecret []byte `protobuf:"bytes,7,opt,name=server_handshake_traffic_secret,json=serverHandshakeTrafficSecret,proto3" json:"server_handshake_traffic_secret,omitempty"`
	// TLS 1.3: Application traffic secrets
	ClientTrafficSecret_0 []byte `protobuf:"bytes,8,opt,name=client_traffic_secret_0,json=clientTrafficSecret0,proto3" json:"client_traffic_secret_0,omitempty"`
	ServerTrafficSecret_0 []byte `protobuf:"bytes,9,opt,name=server_traffic_secret_0,json=serverTrafficSecret0,proto3" json:"server_traffic_secret_0,omitempty"`
	// TLS 1.3: Exporter secrets (optional)
	ExporterSecret      []byte `protobuf:"bytes,10,opt,name=exporter_secret,json=exporterSecret,proto3" json:"exporter_secret,omitempty"`
	EarlyExporterSecret []byte `protobuf:"bytes,11,opt,name=early_exporter_secret,json=earlyExporterSecret,proto3" json:"early_exporter_secret,omitempty"`
	// TLS 1.3: Early traffic secret (0-RTT)
	ClientEarlyTrafficSecret []byte `protobuf:"bytes,12,opt,name=client_early_traffic_secret,json=clientEarlyTrafficSecret,proto3" json:"client_early_traffic_secret,omitempty"`
	// Flow identification for session correlation
	SrcIp         string `protobuf:"bytes,13,opt,name=src_ip,json=srcIp,proto3" json:"src_ip,omitempty"`
	SrcPort       uint32 `protobuf:"varint,14,opt,name=src_port,json=srcPort,proto3" json:"src_port,omitempty"`
	DstIp         string `protobuf:"bytes,15,opt,name=dst_ip,json=dstIp,proto3" json:"dst_ip,omitempty"`
	DstPort       uint32 `protobuf:"varint,16,opt,name=dst_port,json=dstPort,proto3" json:"dst_port,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TLSSessionKeys) Reset() {
	*x = TLSSessionKeys{}
	mi := &file_data_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TLSSessionKeys) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TLSSessionKeys) ProtoMessage() {}

func (x *TLSSessionKeys) ProtoReflect() protoreflect.Message {
	mi := &file_data_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TLSSessionKeys.ProtoReflect.Descriptor instead.
func (*TLSSessionKeys) Descriptor() ([]byte, []int) {
	return file_data_proto_rawDescGZIP(), []int{13}
}

func (x *TLSSessionKeys) GetClientRandom() []byte {
	if x != nil {
		return x.ClientRandom
	}
	return nil
}

func (x *TLSSessionKeys) GetServerRandom() []byte {
	if x != nil {
		return x.ServerRandom
	}
	return nil
}

func (x *TLSSessionKeys) GetTlsVersion() uint32 {
	if x != nil {
		return x.TlsVersion
	}
	return 0
}

func (x *TLSSessionKeys) GetCipherSuite() uint32 {
	if x != nil {
		return x.CipherSuite
	}
	return 0
}

func (x *TLSSessionKeys) GetPreMasterSecret() []byte {
	if x != nil {
		return x.PreMasterSecret
	}
	return nil
}

func (x *TLSSessionKeys) GetClientHandshakeTrafficSecret() []byte {
	if x != nil {
		return x.ClientHandshakeTrafficSecret
	}
	return nil
}

func (x *TLSSessionKeys) GetServerHandshakeTrafficSecret() []byte {
	if x != nil {
		return x.ServerHandshakeTrafficSecret
	}
	return nil
}

func (x *TLSSessionKeys) GetClientTrafficSecret_0() []byte {
	if x != nil {
		return x.ClientTrafficSecret_0
	}
	return nil
}

func (x *TLSSessionKeys) GetServerTrafficSecret_0() []byte {
	if x != nil {
		return x.ServerTrafficSecret_0
	}
	return nil
}

func (x *TLSSessionKeys) GetExporterSecret() []byte {
	if x != nil {
		return x.ExporterSecret
	}
	return nil
}

func (x *TLSSessionKeys) GetEarlyExporterSecret() []byte {
	if x != nil {
		return x.EarlyExporterSecret
	}
	return nil
}

func (x *TLSSessionKeys) GetClientEarlyTrafficSecret() []byte {
	if x != nil {
		return x.ClientEarlyTrafficSecret
	}
	return nil
}

func (x *TLSSessionKeys) GetSrcIp() string {
	if x != nil {
		return x.SrcIp
	}
	return ""
}

func (x *TLSSessionKeys) GetSrcPort() uint32 {
	if x != nil {
		return x.SrcPort
	}
	return 0
}

func (x *TLSSessionKeys) GetDstIp() string {
	if x != nil {
		return x.DstIp
	}
	return ""
}

func (x *TLSSessionKeys) GetDstPort() uint32 {
	if x != nil {
		return x.DstPort
	}
	return 0
}

var File_data_proto protoreflect.FileDescriptor

const file_data_proto_rawDesc = "" +
	"\n" +
	"\n" +
	"data.proto\x12\rlippycat.data\"\xd3\x01\n" +
	"\vPacketBatch\x12\x1b\n" +
	"\thunter_id\x18\x01 \x01(\tR\bhunterId\x12\x1a\n" +
	"\bsequence\x18\x02 \x01(\x04R\bsequence\x12!\n" +
	"\ftimestamp_ns\x18\x03 \x01(\x03R\vtimestampNs\x127\n" +
	"\apackets\x18\x04 \x03(\v2\x1d.lippycat.data.CapturedPacketR\apackets\x12/\n" +
	"\x05stats\x18\x05 \x01(\v2\x19.lippycat.data.BatchStatsR\x05stats\"\xa7\x03\n" +
	"\x0eCapturedPacket\x12\x12\n" +
	"\x04data\x18\x01 \x01(\fR\x04data\x12!\n" +
	"\ftimestamp_ns\x18\x02 \x01(\x03R\vtimestampNs\x12%\n" +
	"\x0ecapture_length\x18\x03 \x01(\rR\rcaptureLength\x12'\n" +
	"\x0foriginal_length\x18\x04 \x01(\rR\x0eoriginalLength\x12'\n" +
	"\x0finterface_index\x18\x05 \x01(\rR\x0einterfaceIndex\x12\x1b\n" +
	"\tlink_type\x18\x06 \x01(\rR\blinkType\x129\n" +
	"\bmetadata\x18\a \x01(\v2\x1d.lippycat.data.PacketMetadataR\bmetadata\x12%\n" +
	"\x0einterface_name\x18\b \x01(\tR\rinterfaceName\x12,\n" +
	"\x12matched_filter_ids\x18\t \x03(\tR\x10matchedFilterIds\x128\n" +
	"\btls_keys\x18\n" +
	" \x01(\v2\x1d.lippycat.data.TLSSessionKeysR\atlsKeys\"\x82\x04\n" +
	"\x0ePacketMetadata\x12\x1a\n" +
	"\bprotocol\x18\x01 \x01(\tR\bprotocol\x12\x15\n" +
	"\x06src_ip\x18\x02 \x01(\tR\x05srcIp\x12\x15\n" +
	"\x06dst_ip\x18\x03 \x01(\tR\x05dstIp\x12\x19\n" +
	"\bsrc_port\x18\x04 \x01(\rR\asrcPort\x12\x19\n" +
	"\bdst_port\x18\x05 \x01(\rR\adstPort\x12\x1c\n" +
	"\ttransport\x18\x06 \x01(\tR\ttransport\x12,\n" +
	"\x03sip\x18\a \x01(\v2\x1a.lippycat.data.SIPMetadataR\x03sip\x12,\n" +
	"\x03rtp\x18\b \x01(\v2\x1a.lippycat.data.RTPMetadataR\x03rtp\x12\x12\n" +
	"\x04info\x18\t \x01(\tR\x04info\x12D\n" +
	"\adetails\x18\n" +
	" \x03(\v2*.lippycat.data.PacketMetadata.DetailsEntryR\adetails\x122\n" +
	"\x05email\x18\v \x01(\v2\x1c.lippycat.data.EmailMetadataR\x05email\x12,\n" +
	"\x03dns\x18\f \x01(\v2\x1a.lippycat.data.DNSMetadataR\x03dns\x1a:\n" +
	"\fDetailsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xad\x02\n" +
	"\vSIPMetadata\x12\x16\n" +
	"\x06method\x18\x01 \x01(\tR\x06method\x12\x17\n" +
	"\acall_id\x18\x02 \x01(\tR\x06callId\x12\x1b\n" +
	"\tfrom_user\x18\x03 \x01(\tR\bfromUser\x12\x17\n" +
	"\ato_user\x18\x04 \x01(\tR\x06toUser\x12#\n" +
	"\rresponse_code\x18\x05 \x01(\rR\fresponseCode\x12.\n" +
	"\x13p_asserted_identity\x18\x06 \x01(\tR\x11pAssertedIdentity\x12\x19\n" +
	"\bfrom_tag\x18\a \x01(\tR\afromTag\x12\x15\n" +
	"\x06to_tag\x18\b \x01(\tR\x05toTag\x12\x19\n" +
	"\bfrom_uri\x18\t \x01(\tR\afromUri\x12\x15\n" +
	"\x06to_uri\x18\n" +
	" \x01(\tR\x05toUri\"~\n" +
	"\vRTPMetadata\x12\x12\n" +
	"\x04ssrc\x18\x01 \x01(\rR\x04ssrc\x12!\n" +
	"\fpayload_type\x18\x02 \x01(\rR\vpayloadType\x12\x1a\n" +
	"\bsequence\x18\x03 \x01(\rR\bsequence\x12\x1c\n" +
	"\ttimestamp\x18\x04 \x01(\rR\ttimestamp\"\xef\x06\n" +
	"\vDNSMetadata\x12%\n" +
	"\x0etransaction_id\x18\x01 \x01(\rR\rtransactionId\x12\x1f\n" +
	"\vis_response\x18\x02 \x01(\bR\n" +
	"isResponse\x12\x16\n" +
	"\x06opcode\x18\x03 \x01(\tR\x06opcode\x12#\n" +
	"\rresponse_code\x18\x04 \x01(\tR\fresponseCode\x12$\n" +
	"\rauthoritative\x18\x05 \x01(\bR\rauthoritative\x12\x1c\n" +
	"\ttruncated\x18\x06 \x01(\bR\ttruncated\x12+\n" +
	"\x11recursion_desired\x18\a \x01(\bR\x10recursionDesired\x12/\n" +
	"\x13recursion_available\x18\b \x01(\bR\x12recursionAvailable\x12-\n" +
	"\x12authenticated_data\x18\t \x01(\bR\x11authenticatedData\x12+\n" +
	"\x11checking_disabled\x18\n" +
	" \x01(\bR\x10checkingDisabled\x12%\n" +
	"\x0equestion_count\x18\v \x01(\rR\rquestionCount\x12!\n" +
	"\fanswer_count\x18\f \x01(\rR\vanswerCount\x12'\n" +
	"\x0fauthority_count\x18\r \x01(\rR\x0eauthorityCount\x12)\n" +
	"\x10additional_count\x18\x0e \x01(\rR\x0fadditionalCount\x12\x1d\n" +
	"\n" +
	"query_name\x18\x0f \x01(\tR\tqueryName\x12\x1d\n" +
	"\n" +
	"query_type\x18\x10 \x01(\tR\tqueryType\x12\x1f\n" +
	"\vquery_class\x18\x11 \x01(\tR\n" +
	"queryClass\x122\n" +
	"\aanswers\x18\x12 \x03(\v2\x18.lippycat.data.DNSAnswerR\aanswers\x123\n" +
	"\x16query_response_time_ms\x18\x13 \x01(\x03R\x13queryResponseTimeMs\x12)\n" +
	"\x10correlated_query\x18\x14 \x01(\bR\x0fcorrelatedQuery\x12'\n" +
	"\x0ftunneling_score\x18\x15 \x01(\x01R\x0etunnelingScore\x12#\n" +
	"\rentropy_score\x18\x16 \x01(\x01R\fentropyScore\"o\n" +
	"\tDNSAnswer\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x12\n" +
	"\x04type\x18\x02 \x01(\tR\x04type\x12\x14\n" +
	"\x05class\x18\x03 \x01(\tR\x05class\x12\x10\n" +
	"\x03ttl\x18\x04 \x01(\rR\x03ttl\x12\x12\n" +
	"\x04data\x18\x05 \x01(\tR\x04data\"\xe5\x01\n" +
	"\rEmailMetadata\x12\x1b\n" +
	"\tmail_from\x18\x01 \x01(\tR\bmailFrom\x12\x17\n" +
	"\arcpt_to\x18\x02 \x03(\tR\x06rcptTo\x12\x18\n" +
	"\asubject\x18\x03 \x01(\tR\asubject\x12\x1d\n" +
	"\n" +
	"message_id\x18\x04 \x01(\tR\tmessageId\x12!\n" +
	"\fbody_preview\x18\x05 \x01(\tR\vbodyPreview\x12\x1b\n" +
	"\tbody_size\x18\x06 \x01(\x05R\bbodySize\x12%\n" +
	"\x0ebody_truncated\x18\a \x01(\bR\rbodyTruncated\"\x9b\x01\n" +
	"\n" +
	"BatchStats\x12%\n" +
	"\x0etotal_captured\x18\x01 \x01(\x04R\rtotalCaptured\x12)\n" +
	"\x10filtered_matched\x18\x02 \x01(\x04R\x0ffilteredMatched\x12\x18\n" +
	"\adropped\x18\x03 \x01(\x04R\adropped\x12!\n" +
	"\fbuffer_usage\x18\x04 \x01(\rR\vbufferUsage\"\x87\x01\n" +
	"\rStreamControl\x12!\n" +
	"\fack_sequence\x18\x01 \x01(\x04R\vackSequence\x12=\n" +
	"\fflow_control\x18\x02 \x01(\x0e2\x1a.lippycat.data.FlowControlR\vflowControl\x12\x14\n" +
	"\x05error\x18\x03 \x01(\tR\x05error\"\x99\x01\n" +
	"\x10SubscribeRequest\x12\x1d\n" +
	"\n" +
	"hunter_ids\x18\x01 \x03(\tR\thunterIds\x12\x1d\n" +
	"\n" +
	"bpf_filter\x18\x02 \x01(\tR\tbpfFilter\x12\x1b\n" +
	"\tclient_id\x18\x03 \x01(\tR\bclientId\x12*\n" +
	"\x11has_hunter_filter\x18\x04 \x01(\bR\x0fhasHunterFilter\"\x9a\x02\n" +
	"\x14CorrelatedCallUpdate\x12%\n" +
	"\x0ecorrelation_id\x18\x01 \x01(\tR\rcorrelationId\x12\x19\n" +
	"\btag_pair\x18\x02 \x03(\tR\atagPair\x12\x1b\n" +
	"\tfrom_user\x18\x03 \x01(\tR\bfromUser\x12\x17\n" +
	"\ato_user\x18\x04 \x01(\tR\x06toUser\x12.\n" +
	"\x04legs\x18\x05 \x03(\v2\x1a.lippycat.data.CallLegInfoR\x04legs\x12\"\n" +
	"\rstart_time_ns\x18\x06 \x01(\x03R\vstartTimeNs\x12 \n" +
	"\flast_seen_ns\x18\a \x01(\x03R\n" +
	"lastSeenNs\x12\x14\n" +
	"\x05state\x18\b \x01(\tR\x05state\"\x97\x02\n" +
	"\vCallLegInfo\x12\x17\n" +
	"\acall_id\x18\x01 \x01(\tR\x06callId\x12\x1b\n" +
	"\thunter_id\x18\x02 \x01(\tR\bhunterId\x12\x15\n" +
	"\x06src_ip\x18\x03 \x01(\tR\x05srcIp\x12\x15\n" +
	"\x06dst_ip\x18\x04 \x01(\tR\x05dstIp\x12\x16\n" +
	"\x06method\x18\x05 \x01(\tR\x06method\x12#\n" +
	"\rresponse_code\x18\x06 \x01(\rR\fresponseCode\x12!\n" +
	"\fpacket_count\x18\a \x01(\x05R\vpacketCount\x12\"\n" +
	"\rstart_time_ns\x18\b \x01(\x03R\vstartTimeNs\x12 \n" +
	"\flast_seen_ns\x18\t \x01(\x03R\n" +
	"lastSeenNs\"\xc6\x05\n" +
	"\x0eTLSSessionKeys\x12#\n" +
	"\rclient_random\x18\x01 \x01(\fR\fclientRandom\x12#\n" +
	"\rserver_random\x18\x02 \x01(\fR\fserverRandom\x12\x1f\n" +
	"\vtls_version\x18\x03 \x01(\rR\n" +
	"tlsVersion\x12!\n" +
	"\fcipher_suite\x18\x04 \x01(\rR\vcipherSuite\x12*\n" +
	"\x11pre_master_secret\x18\x05 \x01(\fR\x0fpreMasterSecret\x12E\n" +
	"\x1fclient_handshake_traffic_secret\x18\x06 \x01(\fR\x1cclientHandshakeTrafficSecret\x12E\n" +
	"\x1fserver_handshake_traffic_secret\x18\a \x01(\fR\x1cserverHandshakeTrafficSecret\x125\n" +
	"\x17client_traffic_secret_0\x18\b \x01(\fR\x14clientTrafficSecret0\x125\n" +
	"\x17server_traffic_secret_0\x18\t \x01(\fR\x14serverTrafficSecret0\x12'\n" +
	"\x0fexporter_secret\x18\n" +
	" \x01(\fR\x0eexporterSecret\x122\n" +
	"\x15early_exporter_secret\x18\v \x01(\fR\x13earlyExporterSecret\x12=\n" +
	"\x1bclient_early_traffic_secret\x18\f \x01(\fR\x18clientEarlyTrafficSecret\x12\x15\n" +
	"\x06src_ip\x18\r \x01(\tR\x05srcIp\x12\x19\n" +
	"\bsrc_port\x18\x0e \x01(\rR\asrcPort\x12\x15\n" +
	"\x06dst_ip\x18\x0f \x01(\tR\x05dstIp\x12\x19\n" +
	"\bdst_port\x18\x10 \x01(\rR\adstPort*P\n" +
	"\vFlowControl\x12\x11\n" +
	"\rFLOW_CONTINUE\x10\x00\x12\r\n" +
	"\tFLOW_SLOW\x10\x01\x12\x0e\n" +
	"\n" +
	"FLOW_PAUSE\x10\x02\x12\x0f\n" +
	"\vFLOW_RESUME\x10\x032\x93\x02\n" +
	"\vDataService\x12M\n" +
	"\rStreamPackets\x12\x1a.lippycat.data.PacketBatch\x1a\x1c.lippycat.data.StreamControl(\x010\x01\x12Q\n" +
	"\x10SubscribePackets\x12\x1f.lippycat.data.SubscribeRequest\x1a\x1a.lippycat.data.PacketBatch0\x01\x12b\n" +
	"\x18SubscribeCorrelatedCalls\x12\x1f.lippycat.data.SubscribeRequest\x1a#.lippycat.data.CorrelatedCallUpdate0\x01B+Z)github.com/endorses/lippycat/api/gen/datab\x06proto3"

var (
	file_data_proto_rawDescOnce sync.Once
	file_data_proto_rawDescData []byte
)

func file_data_proto_rawDescGZIP() []byte {
	file_data_proto_rawDescOnce.Do(func() {
		file_data_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_data_proto_rawDesc), len(file_data_proto_rawDesc)))
	})
	return file_data_proto_rawDescData
}

var file_data_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_data_proto_msgTypes = make([]protoimpl.MessageInfo, 15)
var file_data_proto_goTypes = []any{
	(FlowControl)(0),             // 0: lippycat.data.FlowControl
	(*PacketBatch)(nil),          // 1: lippycat.data.PacketBatch
	(*CapturedPacket)(nil),       // 2: lippycat.data.CapturedPacket
	(*PacketMetadata)(nil),       // 3: lippycat.data.PacketMetadata
	(*SIPMetadata)(nil),          // 4: lippycat.data.SIPMetadata
	(*RTPMetadata)(nil),          // 5: lippycat.data.RTPMetadata
	(*DNSMetadata)(nil),          // 6: lippycat.data.DNSMetadata
	(*DNSAnswer)(nil),            // 7: lippycat.data.DNSAnswer
	(*EmailMetadata)(nil),        // 8: lippycat.data.EmailMetadata
	(*BatchStats)(nil),           // 9: lippycat.data.BatchStats
	(*StreamControl)(nil),        // 10: lippycat.data.StreamControl
	(*SubscribeRequest)(nil),     // 11: lippycat.data.SubscribeRequest
	(*CorrelatedCallUpdate)(nil), // 12: lippycat.data.CorrelatedCallUpdate
	(*CallLegInfo)(nil),          // 13: lippycat.data.CallLegInfo
	(*TLSSessionKeys)(nil),       // 14: lippycat.data.TLSSessionKeys
	nil,                          // 15: lippycat.data.PacketMetadata.DetailsEntry
}
var file_data_proto_depIdxs = []int32{
	2,  // 0: lippycat.data.PacketBatch.packets:type_name -> lippycat.data.CapturedPacket
	9,  // 1: lippycat.data.PacketBatch.stats:type_name -> lippycat.data.BatchStats
	3,  // 2: lippycat.data.CapturedPacket.metadata:type_name -> lippycat.data.PacketMetadata
	14, // 3: lippycat.data.CapturedPacket.tls_keys:type_name -> lippycat.data.TLSSessionKeys
	4,  // 4: lippycat.data.PacketMetadata.sip:type_name -> lippycat.data.SIPMetadata
	5,  // 5: lippycat.data.PacketMetadata.rtp:type_name -> lippycat.data.RTPMetadata
	15, // 6: lippycat.data.PacketMetadata.details:type_name -> lippycat.data.PacketMetadata.DetailsEntry
	8,  // 7: lippycat.data.PacketMetadata.email:type_name -> lippycat.data.EmailMetadata
	6,  // 8: lippycat.data.PacketMetadata.dns:type_name -> lippycat.data.DNSMetadata
	7,  // 9: lippycat.data.DNSMetadata.answers:type_name -> lippycat.data.DNSAnswer
	0,  // 10: lippycat.data.StreamControl.flow_control:type_name -> lippycat.data.FlowControl
	13, // 11: lippycat.data.CorrelatedCallUpdate.legs:type_name -> lippycat.data.CallLegInfo
	1,  // 12: lippycat.data.DataService.StreamPackets:input_type -> lippycat.data.PacketBatch
	11, // 13: lippycat.data.DataService.SubscribePackets:input_type -> lippycat.data.SubscribeRequest
	11, // 14: lippycat.data.DataService.SubscribeCorrelatedCalls:input_type -> lippycat.data.SubscribeRequest
	10, // 15: lippycat.data.DataService.StreamPackets:output_type -> lippycat.data.StreamControl
	1,  // 16: lippycat.data.DataService.SubscribePackets:output_type -> lippycat.data.PacketBatch
	12, // 17: lippycat.data.DataService.SubscribeCorrelatedCalls:output_type -> lippycat.data.CorrelatedCallUpdate
	15, // [15:18] is the sub-list for method output_type
	12, // [12:15] is the sub-list for method input_type
	12, // [12:12] is the sub-list for extension type_name
	12, // [12:12] is the sub-list for extension extendee
	0,  // [0:12] is the sub-list for field type_name
}

func init() { file_data_proto_init() }
func file_data_proto_init() {
	if File_data_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_data_proto_rawDesc), len(file_data_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   15,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_data_proto_goTypes,
		DependencyIndexes: file_data_proto_depIdxs,
		EnumInfos:         file_data_proto_enumTypes,
		MessageInfos:      file_data_proto_msgTypes,
	}.Build()
	File_data_proto = out.File
	file_data_proto_goTypes = nil
	file_data_proto_depIdxs = nil
}
