syntax = "proto3";

package lippycat.data;

option go_package = "github.com/endorses/lippycat/api/gen/data";

// DataService handles high-volume packet streaming from hunters to processors
service DataService {
    // StreamPackets is a bidirectional stream for packet transmission
    // Hunter → Processor: Captured packets
    // Processor → Hunter: Acknowledgments and flow control signals
    rpc StreamPackets(stream PacketBatch) returns (stream StreamControl);

    // SubscribePackets allows monitoring clients (like TUI) to receive packet stream
    // Monitoring Client ← Processor/Hunter: Packet batches
    rpc SubscribePackets(SubscribeRequest) returns (stream PacketBatch);

    // SubscribeCorrelatedCalls allows monitoring clients to receive call correlation updates
    // Monitoring Client ← Processor: Correlated call updates
    rpc SubscribeCorrelatedCalls(SubscribeRequest) returns (stream CorrelatedCallUpdate);
}

// PacketBatch contains multiple packets captured by a hunter
message PacketBatch {
    // Unique hunter identifier
    string hunter_id = 1;

    // Batch sequence number (for ordering and loss detection)
    uint64 sequence = 2;

    // Timestamp when batch was created (Unix nanoseconds)
    int64 timestamp_ns = 3;

    // Individual packets in this batch
    repeated CapturedPacket packets = 4;

    // Statistics about this hunter's capture
    BatchStats stats = 5;
}

// CapturedPacket represents a single captured network packet
message CapturedPacket {
    // Packet payload (raw network data)
    bytes data = 1;

    // Capture timestamp (Unix nanoseconds)
    int64 timestamp_ns = 2;

    // Capture length (actual bytes captured)
    uint32 capture_length = 3;

    // Original length (may be > capture_length if truncated)
    uint32 original_length = 4;

    // Interface index where packet was captured
    uint32 interface_index = 5;

    // Link type (Ethernet, Raw IP, etc.) - from libpcap
    uint32 link_type = 6;

    // Optional: Metadata from local analysis
    PacketMetadata metadata = 7;

    // Interface name where packet was captured (e.g., "eth0", "wlan0")
    // This preserves the actual interface name across hierarchical processor chains
    string interface_name = 8;

    // Matched filter IDs (for LI correlation)
    // Populated by hunters/LocalSource when a packet matches application filters.
    // Used by the processor to correlate packets to LI intercept tasks.
    repeated string matched_filter_ids = 9;

    // TLS session keys for decryption (forwarded on first matched packet of session)
    // Original encrypted packets are preserved for audit integrity.
    // Processor uses these keys to decrypt traffic for display/analysis.
    TLSSessionKeys tls_keys = 10;
}

// PacketMetadata contains hunter-side analysis results
message PacketMetadata {
    // Protocol detected (e.g., "SIP", "RTP", "RTCP")
    string protocol = 1;

    // Source IP address
    string src_ip = 2;

    // Destination IP address
    string dst_ip = 3;

    // Source port
    uint32 src_port = 4;

    // Destination port
    uint32 dst_port = 5;

    // Transport protocol (TCP, UDP, etc.)
    string transport = 6;

    // SIP-specific metadata (if applicable)
    SIPMetadata sip = 7;

    // RTP-specific metadata (if applicable)
    RTPMetadata rtp = 8;

    // Generic info string for display (e.g., "SSH-2.0-OpenSSH_...", "Echo Reply")
    string info = 9;

    // Generic key-value details for protocol-specific data
    map<string, string> details = 10;

    // Email-specific metadata (if applicable)
    EmailMetadata email = 11;

    // DNS-specific metadata (if applicable)
    DNSMetadata dns = 12;
}

// SIPMetadata for SIP packets
message SIPMetadata {
    // SIP method (INVITE, BYE, REGISTER, etc.)
    string method = 1;

    // Call-ID
    string call_id = 2;

    // From user
    string from_user = 3;

    // To user
    string to_user = 4;

    // Response code (for responses)
    uint32 response_code = 5;

    // P-Asserted-Identity header (RFC 3325)
    string p_asserted_identity = 6;

    // From tag parameter (for dialog correlation)
    string from_tag = 7;

    // To tag parameter (for dialog correlation)
    string to_tag = 8;

    // Full From URI (for display)
    string from_uri = 9;

    // Full To URI (for display)
    string to_uri = 10;
}

// RTPMetadata for RTP packets
message RTPMetadata {
    // SSRC identifier
    uint32 ssrc = 1;

    // Payload type
    uint32 payload_type = 2;

    // Sequence number
    uint32 sequence = 3;

    // Timestamp
    uint32 timestamp = 4;
}

// DNSMetadata for DNS packets
message DNSMetadata {
    // Header fields
    uint32 transaction_id = 1;  // DNS transaction ID for query/response correlation
    bool is_response = 2;       // True if response, false if query
    string opcode = 3;          // Operation type (QUERY, IQUERY, STATUS, NOTIFY, UPDATE, DSO)
    string response_code = 4;   // Response code (NOERROR, NXDOMAIN, SERVFAIL, etc.)

    // Header flags
    bool authoritative = 5;       // AA: Authoritative Answer
    bool truncated = 6;           // TC: Message truncated
    bool recursion_desired = 7;   // RD: Recursion Desired
    bool recursion_available = 8; // RA: Recursion Available
    bool authenticated_data = 9;  // AD: Authenticated Data (DNSSEC)
    bool checking_disabled = 10;  // CD: Checking Disabled (DNSSEC)

    // Record counts
    uint32 question_count = 11;   // Number of questions
    uint32 answer_count = 12;     // Number of answer records
    uint32 authority_count = 13;  // Number of authority records
    uint32 additional_count = 14; // Number of additional records

    // Query information (parsed from question section)
    string query_name = 15;  // Queried domain name (e.g., "example.com")
    string query_type = 16;  // Record type (A, AAAA, MX, CNAME, TXT, etc.)
    string query_class = 17; // Query class (usually IN for Internet)

    // Response information (parsed from answer section)
    repeated DNSAnswer answers = 18; // Parsed answer records

    // Correlation and timing
    int64 query_response_time_ms = 19; // Response latency (only for correlated responses)
    bool correlated_query = 20;        // True if response was correlated with a query

    // Security analysis (tunneling detection)
    double tunneling_score = 21; // DNS tunneling probability (0.0-1.0)
    double entropy_score = 22;   // Entropy of query name (for tunneling detection)
}

// DNSAnswer represents a single DNS answer record
message DNSAnswer {
    string name = 1;   // Domain name
    string type = 2;   // Record type (A, AAAA, CNAME, etc.)
    string class = 3;  // Record class (usually IN)
    uint32 ttl = 4;    // Time to live in seconds
    string data = 5;   // Answer data (IP address, CNAME target, etc.)
}

// EmailMetadata for SMTP/email packets
message EmailMetadata {
    // MAIL FROM address
    string mail_from = 1;

    // RCPT TO addresses
    repeated string rcpt_to = 2;

    // Subject header
    string subject = 3;

    // Message-ID header
    string message_id = 4;

    // Body preview (limited to configured max size)
    string body_preview = 5;

    // Full body size in bytes
    int32 body_size = 6;

    // True if body was truncated due to size limit
    bool body_truncated = 7;
}

// BatchStats contains statistics about a hunter's capture
message BatchStats {
    // Total packets captured (before filtering)
    uint64 total_captured = 1;

    // Packets that matched filters
    uint64 filtered_matched = 2;

    // Packets dropped (buffer full, etc.)
    uint64 dropped = 3;

    // Current buffer usage percentage (0-100)
    uint32 buffer_usage = 4;
}

// StreamControl messages from processor to hunter
message StreamControl {
    // Acknowledged sequence number
    uint64 ack_sequence = 1;

    // Flow control signal
    FlowControl flow_control = 2;

    // Error message (if any)
    string error = 3;
}

// FlowControl signals
enum FlowControl {
    // Continue sending at current rate
    FLOW_CONTINUE = 0;

    // Slow down transmission
    FLOW_SLOW = 1;

    // Pause transmission temporarily
    FLOW_PAUSE = 2;

    // Resume after pause
    FLOW_RESUME = 3;
}

// SubscribeRequest for monitoring clients to subscribe to packet stream
message SubscribeRequest {
    // Optional: Filter by specific hunter IDs
    // If has_hunter_filter = false: subscribe to all hunters (default)
    // If has_hunter_filter = true and hunter_ids is empty: subscribe to no hunters
    // If has_hunter_filter = true and hunter_ids is non-empty: subscribe to specific hunters
    repeated string hunter_ids = 1;

    // Optional: BPF filter to apply on server side
    string bpf_filter = 2;

    // Client identifier for logging/tracking
    string client_id = 3;

    // Explicitly indicates whether hunter_ids filter is set
    // This distinguishes between "not set" (subscribe to all) and "empty list" (subscribe to none)
    bool has_hunter_filter = 4;
}

// CorrelatedCallUpdate contains information about a call correlated across B2BUA boundaries
message CorrelatedCallUpdate {
    // Correlation ID (hash of normalized tag pair)
    string correlation_id = 1;

    // Normalized tag pair [tag1, tag2] (sorted alphabetically)
    repeated string tag_pair = 2;

    // From user (participant A)
    string from_user = 3;

    // To user (participant B)
    string to_user = 4;

    // Call legs (one per B2BUA hop)
    repeated CallLegInfo legs = 5;

    // Start time (Unix nanoseconds)
    int64 start_time_ns = 6;

    // Last seen time (Unix nanoseconds)
    int64 last_seen_ns = 7;

    // Call state
    string state = 8;
}

// CallLegInfo represents one leg of a multi-hop call
message CallLegInfo {
    // Call-ID for this leg
    string call_id = 1;

    // Hunter ID where this leg was observed
    string hunter_id = 2;

    // Source IP address
    string src_ip = 3;

    // Destination IP address
    string dst_ip = 4;

    // Last SIP method seen
    string method = 5;

    // Last response code seen
    uint32 response_code = 6;

    // Packet count for this leg
    int32 packet_count = 7;

    // Start time for this leg (Unix nanoseconds)
    int64 start_time_ns = 8;

    // Last seen time for this leg (Unix nanoseconds)
    int64 last_seen_ns = 9;
}

// TLSSessionKeys contains session keys for TLS decryption
// Keys are forwarded from hunters to processors when a TLS session matches filters.
// This enables processors to decrypt traffic for display while storing original
// encrypted packets for audit integrity.
message TLSSessionKeys {
    // Client random (32 bytes) - unique session identifier from ClientHello
    bytes client_random = 1;

    // Server random (32 bytes) - from ServerHello, for correlation
    bytes server_random = 2;

    // TLS version (e.g., 0x0303 for TLS 1.2, 0x0304 for TLS 1.3)
    uint32 tls_version = 3;

    // Cipher suite (e.g., 0x1301 for TLS_AES_128_GCM_SHA256)
    uint32 cipher_suite = 4;

    // TLS 1.2: Pre-master secret (48 bytes)
    bytes pre_master_secret = 5;

    // TLS 1.3: Handshake traffic secrets
    bytes client_handshake_traffic_secret = 6;
    bytes server_handshake_traffic_secret = 7;

    // TLS 1.3: Application traffic secrets
    bytes client_traffic_secret_0 = 8;
    bytes server_traffic_secret_0 = 9;

    // TLS 1.3: Exporter secrets (optional)
    bytes exporter_secret = 10;
    bytes early_exporter_secret = 11;

    // TLS 1.3: Early traffic secret (0-RTT)
    bytes client_early_traffic_secret = 12;

    // Flow identification for session correlation
    string src_ip = 13;
    uint32 src_port = 14;
    string dst_ip = 15;
    uint32 dst_port = 16;
}
